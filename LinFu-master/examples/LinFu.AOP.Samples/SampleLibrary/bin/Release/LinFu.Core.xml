<?xml version="1.0"?>
<doc>
  <assembly>
    <name>LinFu.Core</name>
  </assembly>
  <members>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodBodyRewriter">
      <summary>
            Represents a type that can modify method bodies.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodBodyRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1">
      <summary>
            Represents a weaver class that can modify its host.
            </summary>
      <typeparam name="THost">The host that holds the item to be modified.</typeparam>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports references into the target <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">The module that will hold the modified item.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1.AddAdditionalMembers(`0)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host that holds the current item being modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter">
      <summary>
            Represents a type that can modify method bodies.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.BaseMethodRewriter">
      <summary>
            Represents the basic implementation of a method rewriter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.ShouldRewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the given method should be modified.
            </summary>
      <param name="targetMethod">The target method.</param>
      <returns>A <see cref="T:System.Boolean" /> indicating whether or not a method should be rewritten.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.CatchAllThrownExceptions">
      <summary>
            Represents a method rewriter that modifies a method body to support dynamic exception handling.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body to support dynamic exception handling.
            </summary>
      <param name="targetMethod">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.SaveExceptionInfo(Mono.Cecil.MethodDefinition,LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo)">
      <summary>
            Saves the current <see cref="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo" /> instance.
            </summary>
      <param name="targetMethod">The target method.</param>
      <param name="emitter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance that will emit the current method context.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IInstructionEmitter">
      <summary>
            Represents a type that is capable of manipulating instructions within a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IInstructionEmitter.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits a set of instructions to the given <paramref name="IL">CilWorker</paramref>.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AddMethodReplacementImplementation">
      <summary>
            Represents an instruction emitter that adds method body replacement support to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddMethodReplacementImplementation.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.AddMethodReplacementImplementation" /> class.
            </summary>
      <param name="parameters">The set of parameters that describe the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddMethodReplacementImplementation.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds method body interception to the target method.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AddOriginalInstructions">
      <summary>
            Represents an instruction emitter that adds the original method instructions to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddOriginalInstructions.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction},Mono.Cecil.Cil.Instruction)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.AddOriginalInstructions" /> class.
            </summary>
      <param name="oldInstructions">The original method instructions.</param>
      <param name="endLabel">The instruction label that marks the end of the method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddOriginalInstructions.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds the original instructions to a given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AssemblyDefinitionExtensions">
      <summary>
            A class that extends <see cref="T:Mono.Cecil.AssemblyDefinition" /> instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AssemblyDefinitionExtensions.RemoveStrongName(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Removes the strong-name signature from the <paramref name="sourceAssembly" />.
            </summary>
      <param name="sourceAssembly">
      </param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions">
      <summary>
            A helper class that extends Cecil to support LinFu's weaver model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="typeWeaver">The type weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionStructureVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="typeWeaver">The type weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="methodWeaver">The method weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="methodWeaver">The method weaver.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.EmitAfterInvoke">
      <summary>
            Represents a type that emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitAfterInvoke.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.EmitAfterInvoke" /> class.
            </summary>
      <param name="surroundingImplementation">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="returnValue">The local vaiable that contains the return value of the target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitAfterInvoke.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.EmitBeforeInvoke">
      <summary>
            Represents a type that emits the call to the <see cref="T:LinFu.AOP.Interfaces.IBeforeInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitBeforeInvoke.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.EmitBeforeInvoke" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="surroundingImplementation">The variable that contains the instance-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitBeforeInvoke.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ExceptionHandlerInfo">
      <summary>
            Represents a class that describes the context of a thrown exception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ExceptionHandlerInfo.#ctor(System.Exception,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.ExceptionHandlerInfo" /> class.
            </summary>
      <param name="ex">The thrown exception.</param>
      <param name="invocationInfo">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method call.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.Exception">
      <summary>
            Gets the value indicating the thrown exception.
            </summary>
      <value>The thrown exception.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.InvocationInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method
            that threw the exception.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.ReturnValue">
      <summary>
            Gets or sets the value indicating the return value that will be used in place of the original return value if 
            the exception is intercepted by an <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance.
            </summary>
      <value>The method return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.ShouldSkipRethrow">
      <summary>
            Gets or sets the value indicating whether or not the exception should be rethrown after
            the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> handles the given exception.
            </summary>
      <value>This should be <c>true</c> if the exception should be rethrown, otherwise, it must be <c>false</c>.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions">
      <summary>
            Represents an extension class that adds support for intercepting exceptions thrown at runtime.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptAllExceptions(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptAllExceptions(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The method filter functor that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The method filter functor that will determine which methods should support exception interception.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.AddInvocationInfoActionFactory">
      <summary>
            A factory instance that creates <see cref="T:System.Action`1" /> delegates
            that emit the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> information
            and store it in a local variable named '__invocationInfo___'.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.AddInvocationInfoActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates the <see cref="T:System.Action`1" /> delegate that will emit
            the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> information.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service type.</param>
      <returns>A delegate that can emit the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> context that will allow other developers to infer information about the method currently being executed.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.AssemblyWeaverActionFactory">
      <summary>
            Represents a class that generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to every type in every module of an <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.AssemblyWeaverActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to every type in every module of an <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service request.</param>
      <returns>An action delegate that will apply a specific method weaver to all the types in the given assembly.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.TypeWeaverActionFactory">
      <summary>
            Represents a class that generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to a specific <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.TypeWeaverActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates the <see cref="T:System.Action`2" /> instance that will
            weave the target type.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service request.</param>
      <returns>The <see cref="T:System.Action`2" /> instance that will weave the target type.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetMethodReplacementProvider">
      <summary>
            Represents a class that emits the instructions that obtain an instance-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetMethodReplacementProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.MethodDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetMethodReplacementProvider" /> class.
            </summary>
      <param name="methodReplacementProvider">The local variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="hostMethod">The target method.</param>
      <param name="resolveGetProviderMethod">The functor that will resolve the GetProvider method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetMethodReplacementProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetSurroundingClassImplementation">
      <summary>
            Represents a class that emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingClassImplementation.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Reflection.MethodInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetSurroundingClassImplementation" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="getSurroundingImplementationMethod">The method that will obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingClassImplementation.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetSurroundingImplementationInstance">
      <summary>
            Represents a class that emits the instructions that obtain the current <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingImplementationInstance.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.Instruction)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetSurroundingImplementationInstance" /> class.
            </summary>
      <param name="aroundInvokeProvider">The variable that will hold the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="invocationInfo">
      </param>
      <param name="surroundingImplementation">
      </param>
      <param name="skipGetSurroundingImplementation">
      </param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingImplementationInstance.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the current <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
      <param name="IL">
      </param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetAroundInvokeProvider">
      <summary>
            Represents a class that emits the call to obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetAroundInvokeProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetAroundInvokeProvider" /> class.
            </summary>
      <param name="aroundInvokeProvider">The local variable that holds the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetAroundInvokeProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetInterceptionDisabled">
      <summary>
            Represents a class that emits the instructions that determine whether or not method interception is disabled.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetInterceptionDisabled" /> class.
            </summary>
      <param name="parameters">The <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.#ctor(Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetInterceptionDisabled" /> class.
            </summary>
      <param name="hostMethod">The target method.</param>
      <param name="interceptionDisabled">The local variable that determines whether or not method interception is disabled.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that determine whether or not method interception is disabled.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance responsible for adding or removing instructions to the method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider">
      <summary>
            Represents a class that emits the instructions that obtain a class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider" /> class.
            </summary>
      <param name="parameters">The method body rewriter paramters that describe the </param>
      <param name="resolveGetProviderMethod">The functor that resolves the method that obtains the method replacement provider instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="classMethodReplacementProvider">The variable that contains the class method replacement provider instance.</param>
      <param name="resolveGetProviderMethod">The functor that resolves the method that obtains the method replacement provider instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain a class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that points to the instructions in the method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions">
      <summary>
            Represents an extension class that adds field interception support to a given type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllInstanceFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support intercepting all instance fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllStaticFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support intercepting all static fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllInstanceFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support intercepting all instance fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllStaticFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support intercepting all static fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="methodFilter">The filter that determines which methods on the target type will be modified to support field interception.</param>
      <param name="fieldFilter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.ITypeFilter,LinFu.AOP.Cecil.Interfaces.IFieldFilter)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="hostTypeFilter">The filter that determines the host types to be modified.</param>
      <param name="fieldFilter">The field filter that determines the fields that will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="methodFilter">The filter that determines which methods on the target type will be modified to support field interception.</param>
      <param name="fieldFilter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IFieldFilter">
      <summary>
            Represents a type that determines whether or not a particular field get or set should be intercepted.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IFieldFilter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.FieldReference)">
      <summary>
            Determines whether or not a particular field get or set should be intercepted.
            </summary>
      <param name="hostMethod">The host method.</param>
      <param name="targetField">The target field.</param>
      <returns>Returns <c>true</c> if the field should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.FieldFilterAdapter">
      <summary>
            Represents an adapter class that maps a functor to an <see cref="T:LinFu.AOP.Cecil.Interfaces.IFieldFilter" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.FieldFilterAdapter.#ctor(System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.FieldFilterAdapter" /> class.
            </summary>
      <param name="filter">The field filter.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.FieldFilterAdapter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.FieldReference)">
      <summary>
            Determines whether or not a particular field get or set should be intercepted.
            </summary>
      <param name="hostMethod">The host method.</param>
      <param name="targetField">The target field.</param>
      <returns>Returns <c>true</c> if the field should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.IgnoredInstancesRegistry">
      <summary>
            Represents a class that keeps track of the internal object instances that should be ignored
            by the interception routines.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.IgnoredInstancesRegistry.Contains(System.Object)">
      <summary>
            Determines whether or not the registry contains the given ignored object.
            </summary>
      <param name="target">The target object.</param>
      <returns>Returns <c>true</c> if the object should be ignored; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.IgnoredInstancesRegistry.AddInstance(System.Object)">
      <summary>
            Adds an instance to the list of ignored instances.
            </summary>
      <param name="target">The target instance to be ignored by the interception routines.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter">
      <summary>
            Represents a type that determines which host methods should be modified for method call interception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodFilter.ShouldWeave(Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method should be modified.
            </summary>
      <param name="targetMethod">The target method to be modified.</param>
      <returns>Returns <c>true</c> if the method should be modified; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter">
      <summary>
            Represents a type that determines the method calls that need to be intercepted.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter.ShouldWeave(Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method call should be intercepted.
            </summary>
      <param name="targetType">The host type that contains the method call.</param>
      <param name="hostMethod">The method that contains the current method call.</param>
      <param name="currentMethodCall">The method call to be intercepted.</param>
      <returns>Returns <c>true</c> if the method call should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters">
      <summary>
            Represents the parameters used to add interception to a given method body.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.TargetMethod">
      <summary>
            Gets the value indicating the TargetMethod to be modified.
            </summary>
      <value>The method to be modified.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.AroundInvokeProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.MethodReplacementProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.ClassMethodReplacementProvider">
      <summary>
            Gets the value indicating the class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.InterceptionDisabled">
      <summary>
            Gets the value indicating the local variable that will store the value that determines whether or not
            interception is disabled.
            </summary>
      <value>The value that determines whether or not interception is disabled.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.InvocationInfo">
      <summary>
            Gets the value indicating the local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <value>The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.ReturnValue">
      <summary>
            Gets the value indicating the local variable that will store the return value.
            </summary>
      <value>The value indicating the local variable that will store the return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.RegistryType">
      <summary>
            Gets the value indicating the interception registry type that will be responsible for handling class-level interception events.
            </summary>
      <value>The interception registry type that will be responsible for handling class-level interception events.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.GetMethodReplacementProviderMethod">
      <summary>
            Gets the value indicating the functor that resolves the GetMethodReplacementProvider method.
            </summary>
      <value>The functor that resolves the GetMethodReplacementProvider method.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.OldInstructions">
      <summary>
            Gets the value indicating the list of old instructions in the current method body.
            </summary>
      <value>The value indicating the list of old instructions in the current method body.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter">
      <summary>
            Represents a type that determines the constructor calls that will be intercepted by the postweaver.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular constructor call should be intercepted by the postweaver.
            </summary>
      <param name="currentConstructor">The constructor used to instantiate the current instance.</param>
      <param name="concreteType">The concrete type that contains the new instance call.</param>
      <param name="hostMethod">The host method that contains the new operator call.</param>
      <returns>Returns <c>true</c> if the new operator call should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodCallFilterAdapter">
      <summary>
            Represents a type that converts functors into method call filter instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodCallFilterAdapter.#ctor(System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.MethodCallFilterAdapter" /> class.
            </summary>
      <param name="hostMethodFilter">The method filter that will determine the host methods that will be modified for interception.</param>
      <param name="methodCallFilter">The method filter that will determine which method calls will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodCallFilterAdapter.ShouldWeave(Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method call should be intercepted.
            </summary>
      <param name="targetType">The host type that contains the method call.</param>
      <param name="hostMethod">The method that contains the current method call.</param>
      <param name="currentMethodCall">The method call to be intercepted.</param>
      <returns>Returns <c>true</c> if the method call should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter">
      <summary>
            Represents an adapter class that maps <see cref="T:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter" /> instances to 
            functors.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter.#ctor(System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter" /> class.
            </summary>
      <param name="filter">The filter that determines which instances will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular constructor call should be intercepted by the postweaver.
            </summary>
      <param name="currentConstructor">The constructor used to instantiate the current instance.</param>
      <param name="concreteType">The concrete type that contains the new instance call.</param>
      <param name="hostMethod">The host method that contains the new operator call.</param>
      <returns>Returns <c>true</c> if the new operator call should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IWeaver`2">
      <summary>
            Represents a class that can weave (or modify) 
            a member embedded in an assembly.
            </summary>
      <typeparam name="T">The type of object to modify.</typeparam>
      <typeparam name="THost">The host that holds the item to be modified.</typeparam>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IWeaver`2.ShouldWeave(`0)">
      <summary>
            Determines whether or not the current item should be modified.
            </summary>
      <param name="item">The target item.</param>
      <returns>Returns <c>true</c> if the current item can be modified; otherwise, it should return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IWeaver`2.Weave(`0)">
      <summary>
            Modifies the target <paramref name="item" />.
            </summary>
      <param name="item">The item to be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver">
      <summary>
            Represents a type that can modify an existing <see cref="T:Mono.Cecil.TypeDefinition" />.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver">
      <summary>
            Represents a type weaver that modifies types to implement the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionHost" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.#ctor(System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Initializes a new instance of the ImplementFieldInterceptionHostWeaver class.
            </summary>
      <param name="filter">The filter that determines which types should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.ShouldWeave(Mono.Cecil.TypeDefinition)">
      <summary>
            Determines whether or not a type should be modified.
            </summary>
      <param name="item">
      </param>
      <returns>
        <c>true</c> if the type should be modified; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.Weave(Mono.Cecil.TypeDefinition)">
      <summary>
            Modifies the target type.
            </summary>
      <param name="type">The type to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.AddAdditionalMembers(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional members to the target module.
            </summary>
      <param name="host">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports references into the target module.
            </summary>
      <param name="module">The module containing the type to be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IInstructionProvider">
      <summary>
            Represents a type that can provide the instructions for a given method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IInstructionProvider.GetInstructions(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines the instructions for a given method.
            </summary>
      <param name="method">The source method that contains the instructions.</param>
      <returns>The set of instructions for the given method.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.InstructionProvider">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IInstructionProvider" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionProvider.GetInstructions(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines the instructions for a given method.
            </summary>
      <param name="method">The source method that contains the instructions.</param>
      <returns>The set of instructions for the given method.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.InstructionSwapper">
      <summary>
            Provides the basic functionality for the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a new set of <paramref name="IL" /> instructions..
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody">
      <summary>
            Represents a method body rewriter that surrounds a method body with the necessary prolog and epilogs
            that enable method body interception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody.#ctor(LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.ISurroundMethodBody,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody" /> class.
            </summary>
      <param name="emitter">The emitter that will instantiate the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="getInterceptionDisabled">The emitter that will determine whether or not method interception is enabled.</param>
      <param name="surroundMethodBody">The <see cref="T:LinFu.AOP.Cecil.ISurroundMethodBody" /> instance that will add the epilogs and prologs to the method body.</param>
      <param name="getInstanceMethodReplacementProvider">The emitter that will obtain the method replacement provider instance.</param>
      <param name="getClassMethodReplacementProvider">The emitter that will obtain the class-level method replacement provider instance.</param>
      <param name="addMethodReplacement">The instruction emitter that will add the call to obtain the method body replacement instance. </param>
      <param name="parameters">The parameters that describe the context of the method body rewrite.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptFieldAccess">
      <summary>
            Represents a <see cref="T:LinFu.AOP.Cecil.MethodRewriter" /> that intercepts calls to field getters and setters and redirects those calls to
            a <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.#ctor(System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Initializes a new instance of the InterceptFieldAccess class.
            </summary>
      <param name="filter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.#ctor(LinFu.AOP.Cecil.Interfaces.IFieldFilter)">
      <summary>
            Initializes a new instance of the InterceptFieldAccess class.
            </summary>
      <param name="filter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds locals to the target method.
            </summary>
      <param name="hostMethod">The method to be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds references to the target module.
            </summary>
      <param name="module">The module that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <remarks>The <see cref="T:LinFu.AOP.Cecil.InterceptFieldAccess" /> class only modifies instructions that get or set the value of static and instance fields.</remarks>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a set of new instructions.
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker that will be used to emit the method body instructions.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptMethodBody">
      <summary>
            Represents a method rewriter type that adds interception capabilities to any given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.#ctor(System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InterceptMethodBody" /> class.
            </summary>
      <param name="methodFilter">The method filter that will determine the methods with the method bodies that will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.ShouldRewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the given method should be modified.
            </summary>
      <param name="targetMethod">The target method.</param>
      <returns>A <see cref="T:System.Boolean" /> indicating whether or not a method should be rewritten.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver">
      <summary>
            Represents a class that adds a method
            epilog and prolog to an existing method instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.ShouldWeave(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the current item should be modified.
            </summary>
      <param name="method">The target item.</param>
      <returns>Returns <c>true</c> if the current item can be modified; otherwise, it should return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.AddProlog(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.MethodBody)">
      <summary>
            Adds an prolog to the target method.
            </summary>
      <param name="firstInstruction">The instruction that marks the start of the <paramref name="methodBody" /></param>
      <param name="methodBody">The method body of the target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.AddEpilog(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.MethodBody)">
      <summary>
            Adds an epilog to the target method.
            </summary>
      <param name="lastInstruction">The instruction that marks the end of the <paramref name="methodBody" /></param>
      <param name="methodBody">The method body of the target method.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo">
      <summary>
            Represents a class that emits
            the IL to save information about
            the method currently being executed.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo.Emit(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL to save information about
            the method currently being executed.
            </summary>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
      <param name="targetMethod">The target method currently being executed.</param>
      <param name="currentMethod">The method that will be passed to the <paramref name="invocationInfo" /> as the currently executing method.</param>
      <param name="invocationInfo">The local variable that will store the resulting <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver">
      <summary>
            Represents a type that can modify <see cref="T:Mono.Cecil.MethodDefinition" /> objects.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IModuleWeaver">
      <summary>
            Represents a class that can modify existing <see cref="T:Mono.Cecil.ModuleDefinition" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver">
      <summary>
            Represents a type that can emit IL that instantiates an object
            within a given method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.ShouldIntercept(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not the object instantiation call to the <paramref name="constructor" />
            should be instrumented.
            </summary>
      <param name="constructor">The constructor that will be used to instantiate the target type.</param>
      <param name="concreteType">The type to be created.</param>
      <param name="hostMethod">The method that contains the instantiation request.</param>
      <returns>
        <c>true</c> if the call to the <c>new</c> operator should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.EmitNewObject(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.TypeReference)">
      <summary>
            Emits the necessary <paramref name="IL" /> necessary to instantiate
            the <paramref name="concreteType" />.
            </summary>
      <param name="hostMethod">The method that contains the activation request.</param>
      <param name="IL">The CilWorker that will be used to replace the existing instructions in the method body.</param>
      <param name="targetConstructor">The constructor that is currently being used to instantiate the concrete type.</param>
      <param name="concreteType">The <see cref="T:System.Type" /> that describes the object type that needs to be instantiated.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader">
      <summary>
            Represents a type that can load PDB files from disk.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.LoadAssembly(System.Byte[],System.Byte[])">
      <summary>
            Loads an assembly into memory.
            </summary>
      <param name="assemblyArray">The bytes that represent the target assembly.</param>
      <param name="pdbBytes">The bytes that represent the PDB file.</param>
      <returns>A <see cref="T:System.Reflection.Assembly" /> that represents the loaded assembly.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.LoadSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Loads the debug symbols from the target <paramref name="assembly" />.
            </summary>
      <param name="assembly">The assembly that contains the symbols to be loaded.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.SaveSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Saves the debug symbols for the  target<paramref name="assembly" />.
            </summary>
      <param name="targetAssembly">The assembly that contains the symbols to be saved.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvocationInfo">
      <summary>
            Represents the information associated with 
            a single method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfo.#ctor(System.Object,System.Reflection.MethodBase,System.Diagnostics.StackTrace,System.Type[],System.Type[],System.Type,System.Object[])">
      <summary>
            Initializes the <see cref="T:LinFu.AOP.Cecil.InvocationInfo" /> instance.
            </summary>
      <param name="target">The target instance currently being called.</param>
      <param name="targetMethod">The method currently being called.</param>
      <param name="stackTrace"> The <see cref="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace" /> associated with the method call when the call was made.</param>
      <param name="parameterTypes">The parameter types for the current target method.</param>
      <param name="typeArguments">
            If the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </param>
      <param name="returnType">The return type of the target method.</param>
      <param name="arguments">The arguments used in the method call.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.CallingMethod">
      <summary>
            This is the actual calling method that invoked the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.Target">
      <summary>
            The target instance currently being called.
            </summary>
      <remarks>This typically is a reference to a proxy object.</remarks>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod">
      <summary>
            The method currently being called.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace">
      <summary>
            The <see cref="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace" /> associated
            with the method call when the call was made.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.ReturnType">
      <summary>
            The return type of the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.ParameterTypes">
      <summary>
            The parameter types for the current target method.
            </summary>
      <remarks>
        <para>
            This could be very useful in cases where the actual target method
            is based on a generic type definition. In such cases, 
            the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance needs to be able
            to describe the actual parameter types being used by the
            current generic type instantiation. This property helps
            users determine which parameter types are actually being used
            at the time of the method call.
            </para>
      </remarks>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.TypeArguments">
      <summary>
            If the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.Arguments">
      <summary>
            The arguments used in the method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvocationInfoEmitter">
      <summary>
            Represents the default implementation for the
            <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.#ctor">
      <summary>
            Initializes a new instance of the InvocationInfoEmitter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the InvocationInfoEmitter class.
            </summary>
      <param name="pushStackTrace">Determines whether or not stack trace information will be available at runtime.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.Emit(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL to save information about
            the method currently being executed.
            </summary>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
      <param name="targetMethod">The target method currently being executed.</param>
      <param name="interceptedMethod">The method that will be passed to the <paramref name="invocationInfo" /> as the currently executing method.</param>
      <param name="invocationInfo">The local variable that will store the resulting <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions">
      <summary>
            Adds helper methods classes that implement the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> 
            interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Emit(LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo,System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL instructions that will store information about the method <paramref name="targetMethod">currently being executed</paramref>
            and stores the results into the <paramref name="invocationInfo">variable.</paramref></summary>
      <param name="emitter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance.</param>
      <param name="method">The method whose implementation will be intercepted.</param>
      <param name="targetMethod">The actual method that will contain the resulting instructions.</param>
      <param name="invocationInfo">The <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see> that will store the current <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Invokes the currently executing method by using the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo,System.Object)">
      <summary>
            Invokes the currently executing method by using the <paramref name="target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <param name="target">The target instance that will handle the method call.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo,System.Object,System.Object[])">
      <summary>
            Invokes the currently executing method by using the <paramref name="target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <paramref name="arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <param name="target">The target instance that will handle the method call.</param>
      <param name="arguments">The arguments that will be used for the actual method call.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IVerifier">
      <summary>
            A class that verifies a given <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IVerifier.Verify(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Verifies the given <paramref name="assembly" /> instance.
            </summary>
      <param name="assembly">The assembly definition that needs to be verified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvokeMethodReplacement">
      <summary>
            Represents a class that emits the instructions that call the method replacement instead of the original method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvokeMethodReplacement.#ctor(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InvokeMethodReplacement" /> class.
            </summary>
      <param name="executeOriginalInstructions">The instruction label that will be used if the original instructions should be executed.</param>
      <param name="methodReplacementProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="classMethodReplacementProvider">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvokeMethodReplacement.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that call the method replacement instead of the original method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ISurroundMethodBody">
      <summary>
            Represents a type that can add a prolog and epilog instructions to a particular method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ISurroundMethodBody.AddProlog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds a prolog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ISurroundMethodBody.AddEpilog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds an epilog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ITypeFilter">
      <summary>
            Represents a type that determines whether or not a particular type should be modified.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ITypeFilter.ShouldWeave(Mono.Cecil.TypeReference)">
      <summary>
            Determines whether or not a type should be modified.
            </summary>
      <param name="type">The target type.</param>
      <returns>Returns <c>true</c> if the type should be modified.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport">
      <summary>
            Represents an <see cref="P:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.AssemblyLoader" /> class that adds support for loading PDB files into memory every time an assembly is loaded into memory.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.#ctor(LinFu.Reflection.IAssemblyLoader)">
      <summary>
            Initializes a new instance of the AssemblyLoaderWithPdbSupport class.
            </summary>
      <param name="loader">The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will perform the actual load operation.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.Load(System.String)">
      <summary>
            Loads the target assembly (and its corresponding PDB file) into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.RemoveTemporaryFiles(System.String,System.String,System.String,System.String)">
      <summary>
            Removes the temporary backup files that were created during the load operation.
            </summary>
      <param name="assemblyFile">The full path and location of the original assembly file.</param>
      <param name="pdbFile">The full path and location of the original PDB file.</param>
      <param name="pdbTempFileName">The full path and location of the temporary pdb file.</param>
      <param name="assemblyBackupFile">The full path and location of the backup assembly file.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.AssemblyLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will be used to load assemblies into memory.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.JITWeaver">
      <summary>
            Represents a loader that modifies a given assembly prior to being loaded from disk.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.Loaders.JITWeaver" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IPdbLoader)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.Loaders.JITWeaver" /> class.
            </summary>
      <param name="pdbLoader">The loader that will be responsible for loading the program debugging information into memory.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.Load(System.String)">
      <summary>
            Modifies a given assembly prior to being loaded from disk.
            </summary>
      <param name="assemblyFile">The filename of the target assembly.</param>
      <returns>A valid assembly.</returns>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.PdbLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader" /> that will be used to load debug symbols into memory.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.AssemblyWeavers">
      <summary>
            Gets the value indicating the list of <see cref="T:System.Action`1" /> delegates
            that will be used to modify the assemblies loaded into memory.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.AssemblyVerifier">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Cecil.Interfaces.IVerifier" />
            instance that will be used to ensure that the modified assemblies are valid.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.PdbLoader">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.LoadAssembly(System.Byte[],System.Byte[])">
      <summary>
            Loads an assembly into memory.
            </summary>
      <param name="assemblyArray">The bytes that represent the target assembly.</param>
      <param name="pdbBytes">The bytes that represent the PDB file.</param>
      <returns>A <see cref="T:System.Reflection.Assembly" /> that represents the loaded assembly.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.LoadSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Loads the debug symbols from the target <paramref name="assembly" />.
            </summary>
      <param name="assembly">The assembly that contains the symbols to be loaded.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.SaveSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Saves the debug symbols for the  target<paramref name="assembly" />.
            </summary>
      <param name="targetAssembly">The assembly that contains the symbols to be saved.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodBodyRewriterParameters">
      <summary>
            Represents the parameters used to add interception to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodBodyRewriterParameters.#ctor(Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction},Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference},System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.MethodBodyRewriterParameters" /> class.
            </summary>
      <param name="IL">The CilWorker that is responsible for the current method body.</param>
      <param name="oldInstructions">The value indicating the list of old instructions in the current method body.</param>
      <param name="interceptionDisabled">The value that determines whether or not interception is disabled.</param>
      <param name="invocationInfo">The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="returnValue">The value indicating the local variable that will store the return value.</param>
      <param name="methodReplacementProvider">The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="aroundInvokeProvider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="classMethodReplacementProvider">The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="getMethodReplacementProviderMethod">The functor that resolves the GetMethodReplacementProvider method.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.OldInstructions">
      <summary>
            Gets the value indicating the list of old instructions in the current method body.
            </summary>
      <value>The value indicating the list of old instructions in the current method body.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.ClassMethodReplacementProvider">
      <summary>
            Gets the value indicating the class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.AroundInvokeProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.MethodReplacementProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.TargetMethod">
      <summary>
            Gets the value indicating the TargetMethod to be modified.
            </summary>
      <value>The method to be modified.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.InterceptionDisabled">
      <summary>
            Gets the value indicating the local variable that will store the value that determines whether or not
            interception is disabled.
            </summary>
      <value>The value that determines whether or not interception is disabled.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.InvocationInfo">
      <summary>
            Gets the value indicating the local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <value>The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.ReturnValue">
      <summary>
            Gets the value indicating the local variable that will store the return value.
            </summary>
      <value>The value indicating the local variable that will store the return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.RegistryType">
      <summary>
            Gets the value indicating the interception registry type that will be responsible for handling class-level interception events.
            </summary>
      <value>The interception registry type that will be responsible for handling class-level interception events.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.GetMethodReplacementProviderMethod">
      <summary>
            Gets the value indicating the functor that resolves the GetMethodReplacementProvider method.
            </summary>
      <value>The functor that resolves the GetMethodReplacementProvider method.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodDefinitionExtensions">
      <summary>
            Represents an extension class that adds helper methods to the <see cref="T:Mono.Cecil.MethodDefinition" /> type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a local variable to the given method.
            </summary>
      <param name="methodDef">The target method.</param>
      <param name="localType">The variable type.</param>
      <returns>A local variable definition.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions">
      <summary>
            Represents an extension class that adds method body interception support to the Mono.Cecil object model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptAllMethodBodies(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptAllMethodBodies(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions">
      <summary>
            Represents an extension class that adds method call interception support to the Mono.Cecil object model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptAllMethodCalls(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptAllMethodCalls(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The type filter that determines which types will be modified for interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The type filter that determines the types that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodCallFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="methodCallFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter" /> instance that determines the method calls that will be intercepted.</param>
      <param name="hostMethodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that determines the host method calls that will be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodCallFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="methodCallFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter" /> instance that determines the method calls that will be intercepted.</param>
      <param name="hostMethodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that determines the host method calls that will be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The filter that will determine the target types that will be modified.</param>
      <param name="hostMethodFilter">The filter that will determine the methods that will be modified on the target type.</param>
      <param name="methodCallFilter">The filter that will determine which third-party methods will be intercepted on the target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The filter that will determine the target types that will be modified.</param>
      <param name="hostMethodFilter">The filter that will determine the methods that will be modified on the target type.</param>
      <param name="methodCallFilter">The filter that will determine which third-party methods will be intercepted on the target type.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodRewriter">
      <summary>
            Provides the basic functionality for the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a new set of <paramref name="IL" /> instructions..
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions">
      <summary>
            A helper class that extends Cecil to support the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions.WeaveWith(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Transforms the methods in the <paramref name="target" /> using the given method rewriter.
            </summary>
      <param name="target">The transformation target.</param>
      <param name="rewriter">The method rewriter.</param>
      <param name="filter">The method filter that determines which methods will be rewritten.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions.WeaveWith(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Transforms the methods in the <paramref name="target" /> using the given method rewriter.
            </summary>
      <param name="target">The transformation target.</param>
      <param name="rewriter">The method rewriter.</param>
      <param name="filter">The method filter that determines which methods will be rewritten.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodWeaver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the MethodWeaver class.
            </summary>
      <param name="rewriter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> instance that will modify the existing method.</param>
      <param name="filter">The filter that determines which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodRewriter,LinFu.AOP.Cecil.Interfaces.IInstructionProvider,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the MethodWeaver class.
            </summary>
      <param name="rewriter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> instance that will modify the existing method.</param>
      <param name="instructionProvider">The provider that will obtain the original instructions for the target method.</param>
      <param name="filter">The filter that determines which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.ShouldWeave(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not a method should be modified.
            </summary>
      <param name="item">The target method.</param>
      <returns>
        <c>true</c> if the method should be modified; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.Weave(Mono.Cecil.MethodDefinition)">
      <summary>
            Modifies a target method.
            </summary>
      <param name="method">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the target type.
            </summary>
      <param name="host">The target type to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports additional references into the given module.
            </summary>
      <param name="module">The module that will store the additional references.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.Rewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Rewrites an existing method.
            </summary>
      <param name="method">The method that needs to be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodWeaverVisitor">
      <summary>
            Represents a visitor class that can iterate over <see cref="T:Mono.Cecil.MethodDefinition" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Initializes a new instance of the MethodWeaverVisitor class.
            </summary>
      <param name="methodWeaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> that will be used to modify a given type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitConstructor(Mono.Cecil.MethodDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.MethodDefinition" /> instance.
            </summary>
      <param name="ctor">The <see cref="T:Mono.Cecil.MethodDefinition" /> instance that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitMethodDefinition(Mono.Cecil.MethodDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.MethodDefinition" /> instance.
            </summary>
      <param name="method">The <see cref="T:Mono.Cecil.MethodDefinition" /> instance that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitModuleDefinition(Mono.Cecil.ModuleDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">A <see cref="T:Mono.Cecil.ModuleDefinition" /> object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitTypeDefinition(Mono.Cecil.TypeDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
      <param name="type">A <see cref="T:Mono.Cecil.TypeDefinition" /> object.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions">
      <summary>
            An extension class that adds support for intercepting the 'new' operator with LinFu.AOP.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptAllNewInstances(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting all calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptAllNewInstances(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting all calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="constructorFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <param name="typeFilter">The filter that determines which types will be modified.</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="constructorFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.INewInstanceFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="newInstanceFilter">The filter that will determine which constructor calls should be intercepted.</param>
      <param name="methodFilter">The filter that will determine which host methods should be modified to support new instance interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.INewInstanceFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="newInstanceFilter">The filter that will determine which constructor calls should be intercepted.</param>
      <param name="methodFilter">The filter that will determine which host methods should be modified to support new instance interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstancesWith(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.INewObjectWeaver,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the methods in the given <paramref name="target" /> using the custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> instance.
            </summary>
      <param name="target">The host that contains the methods that will be modified.</param>
      <param name="weaver">The custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> that will replace all calls to the new operator with the custom code emitted by the given weaver.</param>
      <param name="filter">The method filter that will determine which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstancesWith(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.INewObjectWeaver,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the methods in the given <paramref name="target" /> using the custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> instance.
            </summary>
      <param name="target">The host that contains the methods that will be modified.</param>
      <param name="weaver">The custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> that will replace all calls to the new operator with the custom code emitted by the given weaver.</param>
      <param name="filter">The method filter that will determine which methods should be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.SaveReturnValue">
      <summary>
            Represents an instruction emitter that saves the return value from a given method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.SaveReturnValue.#ctor(Mono.Cecil.TypeReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.SaveReturnValue" /> class.
            </summary>
      <param name="returnType">The return type.</param>
      <param name="returnValue">The return value.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SaveReturnValue.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Saves the return value from a given method call.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.SurroundMethodBody">
      <summary>
            Represents a class that surrounds a call site with calls to an <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> class.
            </summary>
      <param name="parameters">The parameters that describe the context of the emitter call.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> class.
            </summary>
      <param name="methodReplacementProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="aroundInvokeProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="interceptionDisabled">The variable that determines whether or not interception is disabled</param>
      <param name="returnValue">The variable that contains the method return value.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.AddProlog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds a prolog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.AddEpilog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds an epilog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.TypeDefinitionExtensions">
      <summary>
            Adds helper methods to the <see cref="T:Mono.Cecil.TypeDefinition" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.TypeDefinitionExtensions.WeaveWith(Mono.Cecil.TypeDefinition,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Applies a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to all methods
            within the given <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target module.</param>
      <param name="weaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance that will modify the methods in the given target type.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.TypeWeaverVisitor">
      <summary>
            Represents a visitor class that can iterate over <see cref="T:Mono.Cecil.TypeDefinition" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.TypeWeaverVisitor.#ctor(LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Initializes a new instance of the TypeWeaverVisitor class.
            </summary>
      <param name="weaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> that will be used to modify a given type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.TypeWeaverVisitor.VisitTypeDefinition(Mono.Cecil.TypeDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
      <param name="type">A <see cref="T:Mono.Cecil.TypeDefinition" /> object.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptor">
      <summary>
            Represents a type that can intercept field getter and setter calls.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.CanIntercept(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Determines whether or not a field can be intercepted.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <returns>
        <c>true</c> if it can be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.GetValue(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Gets the value of a field.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <returns>The value of the target field.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.SetValue(LinFu.AOP.Interfaces.IFieldInterceptionContext,System.Object)">
      <summary>
            Sets the value of a field.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <param name="value">The original value that will be assigned to the target field.</param>
      <returns>The value that will be assigned to the target field.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvokeHost">
      <summary>
            Represents a type that supports injecting code around a method body or method call.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IAroundInvokeHost.AroundMethodBodyProvider">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" />
            that will be used to inject code "around" a particular method body
            implementation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IAroundInvokeHost.AroundMethodCallProvider">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" />
            that will be used to inject code "around" a particular method call
            implementation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IBeforeInvoke">
      <summary>
            Represents a class that is invoked before a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IBeforeInvoke.BeforeInvoke(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            This method will be called just before the actual
            method call is executed.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAfterInvoke">
      <summary>
            Represents a class that is invoked after a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IAfterInvoke.AfterInvoke(LinFu.AOP.Interfaces.IInvocationInfo,System.Object)">
      <summary>
            This method will be called immediately after the actual
            method call is executed.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <param name="returnValue">The value returned from the actual method call.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvoke">
      <summary>
            Represents a class that can wrap itself around any given method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry">
      <summary>
            Represents a registry class that handles all class-level method call interception operations for all modified types.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current method call.</param>
      <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be used to wrap a method call or method body.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.AddProvider(LinFu.AOP.Interfaces.IAroundInvokeProvider)">
      <summary>
            Adds an <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> to the list of provider instances.
            </summary>
      <param name="provider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.Clear">
      <summary>
            Clears the list of <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ActivatorExtensions">
      <summary>
            An extension class that adds helper methods to the <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivatorExtensions.CreateInstance(LinFu.AOP.Interfaces.IActivator{LinFu.AOP.Interfaces.IActivationContext},System.Type,System.Object[])">
      <summary>
            Instantiates the <paramref name="targetType" /> with the given <paramref name="activator" /> and <paramref name="constructorArguments" />.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> instance that will be responsible for creating the <paramref name="targetType" />.</param>
      <param name="targetType">The type to be created.</param>
      <param name="constructorArguments">The arguments that will be passed to the constructor.</param>
      <returns>An object reference that matches the given <paramref name="targetType" />.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivatorExtensions.CreateInstance``1(LinFu.AOP.Interfaces.IActivator{LinFu.AOP.Interfaces.IActivationContext},System.Object[])">
      <summary>
            Instantiates the <paramref name="targetType" /> with the given <paramref name="activator" /> and <paramref name="constructorArguments" />.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> instance that will be responsible for creating the target type.</param>
      <param name="constructorArguments">The arguments that will be passed to the constructor.</param>
      <typeparam name="T">The target type that will be instantiated by the activator.</typeparam>
      <returns>An object reference that matches the given <paramref name="targetType" />.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInvocationInfo">
      <summary>
            Represents the information associated with 
            a single method call.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.Target">
      <summary>
            The target instance currently being called.
            </summary>
      <remarks>This typically is a reference to a proxy object.</remarks>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod">
      <summary>
            The method currently being called.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.ReturnType">
      <summary>
            The return type of the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.StackTrace">
      <summary>
            The <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.StackTrace" /> associated
            with the method call when the call was made.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.ParameterTypes">
      <summary>
            The parameter types for the current target method.
            </summary>
      <remarks>
        <para>
            This could be very useful in cases where the actual target method
            is based on a generic type definition. In such cases, 
            the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance needs to be able
            to describe the actual parameter types being used by the
            current generic type instantiation. This property helps
            users determine which parameter types are actually being used
            at the time of the method call.
            </para>
      </remarks>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.TypeArguments">
      <summary>
            If the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments">
      <summary>
            The arguments used in the method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.BootStrapRegistry">
      <summary>
            Represents a registry class that bootstraps components into memory when the application starts.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootStrapRegistry.Initialize">
      <summary>
            Initializes the BootStrapRegistry.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootStrapRegistry.GetComponents">
      <summary>
            Returns the list of components that have been initialized by the bootstrapper.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:LinFu.AOP.Interfaces.BootStrapRegistry.Instance">
      <summary>
            Gets the value indicating the BootStrapRegistry instance.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry">
      <summary>
            Represents a static type that allows users to register a method replacement provider from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry.GetProvider(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Returns the provider that is currently attached to the registry.
            </summary>
      <param name="host">The type that is currently being intercepted.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the invocation context.</param>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry.SetProvider(LinFu.AOP.Interfaces.IMethodReplacementProvider)">
      <summary>
            Assigns the <paramref name="provider" /> to the MethodReplacementProvider registry.
            </summary>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IMethodReplacementHost">
      <summary>
            Represents a type that can have its method body  implementations replaced at runtime.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IMethodReplacementHost.MethodBodyReplacementProvider">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will be used to swap method body implementations at runtime.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IMethodReplacementHost.MethodCallReplacementProvider">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will be used to swap method body implementations at runtime.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo">
      <summary>
            Represents a type that describes the context of a thrown exception.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.Exception">
      <summary>
            Gets the value indicating the thrown exception.
            </summary>
      <value>The thrown exception.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.InvocationInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method
            that threw the exception.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.ReturnValue">
      <summary>
            Gets or sets the value indicating the return value that will be used in place of the original return value if 
            the exception is intercepted by an <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance.
            </summary>
      <value>The method return value.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.ShouldSkipRethrow">
      <summary>
            Gets or sets the value indicating whether or not the exception should be rethrown after
            the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> handles the given exception.
            </summary>
      <value>This should be <c>true</c> if the exception should be rethrown, otherwise, it must be <c>false</c>.</value>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IExceptionHandler">
      <summary>
            Represents a type that can catch thrown exceptions.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IExceptionHandler.CanCatch(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Determines whether or not an exception can be handled.
            </summary>
      <param name="exceptionHandlerInfo">The object that describes the exception being thrown.</param>
      <returns>
        <c>True</c> if the exception can be handled by the current handler.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IExceptionHandler.Catch(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Handles the exception specified in the <paramref name="exceptionHandlerInfo" /> instance.
            </summary>
      <param name="exceptionHandlerInfo">The object that describes the exception being thrown.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry">
      <summary>
            Represents a registry class that allows users to intercept fields from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptorRegistry.GetInterceptor(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Gets current the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> associated with the <see cref="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> instance that describes the state of the method call when the field getter or setter is called.</param>
      <returns>The field interceptor that will be used to preempt field getter and setter calls.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptorRegistry.SetInterceptor(LinFu.AOP.Interfaces.IFieldInterceptor)">
      <summary>
            Sets current the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> that will be associated with the <see cref="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry" />.
            </summary>
      <param name="interceptor">The field interceptor that will be used to preempt field getter and setter calls.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ExceptionHandlerRegistry">
      <summary>
            Represents a class that stores <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instances in a central location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ExceptionHandlerRegistry.GetHandler(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Gets the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance that can handle the current exception.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo" /> instance that describes the context of the thrown exception.</param>
      <returns>An exception handler.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ExceptionHandlerRegistry.SetHandler(LinFu.AOP.Interfaces.IExceptionHandler)">
      <summary>
            Sets the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance that can handle all thrown exceptions.
            </summary>
      <param name="handler">The exception handler.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.BootstrapException">
      <summary>
            Represents an exception thrown when LinFu.AOP is unable to bootstrap itself.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootstrapException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Interfaces.BootstrapException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="ex">The exception itself.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.TypeActivatorRegistry">
      <summary>
            Represents a registry that allows users to statically register <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivatorRegistry.GetActivator(LinFu.AOP.Interfaces.ITypeActivationContext)">
      <summary>
            Obtains an activator for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivationContext" /> instance that describes the object to be created.</param>
      <returns>A method activator.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivatorRegistry.SetActivator(LinFu.AOP.Interfaces.ITypeActivator)">
      <summary>
            Sets the <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that will be used to 
            instantiate object instances.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that will instantiate types.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInvokeWrapper">
      <summary>
            Represents a special type of interceptor that can
            wrap itself around a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IInvokeWrapper.DoInvoke(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            This method will provide the actual implementation
            for the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod">target method</see>
            instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <returns>The actual return value from the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" />.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivationContext.TargetType">
      <summary>
            Gets the value indicating the type to be instantiated.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivationContext.AdditionalArguments">
      <summary>
            Gets the value indicating the arguments that will be passed to the constructor during instantiation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IMethodReplacementProvider">
      <summary>
            Represents a type that can swap method body implementations at runtime.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IMethodReplacementProvider.CanReplace(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Determines whether or not the current method implementation can be replaced.
            </summary>
      <param name="host">The target instance of the method call.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>
        <c>true</c> if the method can be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IMethodReplacementProvider.GetMethodReplacement(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to replace the current method call.
            </summary>
      <param name="host">The target instance of the method call.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>The interceptor that will intercept the method call itself.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ITypeActivationContext">
      <summary>
            Represents a special type of <see cref="T:LinFu.AOP.Interfaces.IActivationContext" /> that can be used to instantiate a given type
            and can be used to describe the method that invoked the instantiation operation as well as specify the object
            instance that invoked the instantiation itself.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ITypeActivationContext.Target">
      <summary>
            Gets the value indicating the object instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ITypeActivationContext.TargetMethod">
      <summary>
            Gets the value indiating the <see cref="T:System.Reflection.MethodBase" /> instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptionContext">
      <summary>
            Represents a class that describes the state of a field just as it is being intercepted.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.Target">
      <summary>
            Gets a value indicating the target instance that is attached to the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.TargetMethod">
      <summary>
            Gets a value indicating the host method that is currently accessing the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.TargetField">
      <summary>
            Gets a value indicating the field that is currently being accessed by the target method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.HostType">
      <summary>
            Gets a value indicating the <see cref="T:System.Type" /> that holds the target field.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivatorHost">
      <summary>
            Represents a type that can intercept activation requests.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivatorHost.Activator">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that
            will be used to instantiate object types.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IModifiableType">
      <summary>
            Represents a type that has been modified to support
            pervasive method interception.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IModifiableType.IsInterceptionDisabled">
      <summary>
            Gets or sets the value indicating whether or not 
            method interception should be disabled.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivator`1">
      <summary>
            Represents a class that can instantiate object instances.
            </summary>
      <typeparam name="TContext">
            The type that describes the context of the object instantiation.
            </typeparam>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IActivator`1.CreateInstance(`0)">
      <summary>
            Creates an object instance.
            </summary>
      <param name="context">The context that describes the request to instantiate the target type.</param>
      <returns>A valid object instance.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry">
      <summary>
            Represents a static type that allows users to register a method replacement provider from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry.GetProvider(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Returns the provider that is currently attached to the registry.
            </summary>
      <param name="host">The type that is currently being intercepted.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the invocation context.</param>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry.SetProvider(LinFu.AOP.Interfaces.IMethodReplacementProvider)">
      <summary>
            Assigns the <paramref name="provider" /> to the MethodReplacementProvider registry.
            </summary>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ITypeActivator">
      <summary>
            Represents an <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> that can instantiate objects from within a particular method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ITypeActivator.CanActivate(LinFu.AOP.Interfaces.ITypeActivationContext)">
      <summary>
            Determines whether or not a type can be instantiated using the 
            <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivationContext" /> instance that describes the type to be created.</param>
      <returns>
        <c>true</c> if the type can be created; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInterceptor">
      <summary>
            Represents a class that can dynamically intercept method calls.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call using the given
            <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that will 
            contain all the necessary information associated with a 
            particular method call.</param>
      <returns>The return value of the target method. If the return type of the target
            method is <see cref="!:void" />, then the return value will be ignored.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IBootStrappedComponent">
      <summary>
            Represents a type that will be automatically initialized once the LinFu.AOP assembly is loaded into memory.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IBootStrappedComponent.Initialize">
      <summary>
            Initializes the bootstrapped component.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvokeProvider">
      <summary>
            Represents a class that injects code around a method implementation.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IAroundInvokeProvider.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be executed
            before and after the target method (specified in the <paramref name="context" /> parameter)
            is called.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call at the call site.</param>        /// <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance if the surrounding behavior can be found; otherwise, it should return <c>null</c>.</returns></member>
    <member name="T:LinFu.AOP.Interfaces.ActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivationContext.#ctor(System.Type,System.Object[])">
      <summary>
            Initializes the context with the given parameters.
            </summary>
      <param name="concreteType">The type to be instantiated.</param>
      <param name="additionalArguments">The additional arguments that must be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ActivationContext.TargetType">
      <summary>
            Gets the value indicating the type to be instantiated.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ActivationContext.AdditionalArguments">
      <summary>
            Gets the value indicating the arguments that will be passed to the constructor during instantiation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.AroundMethodBodyRegistry">
      <summary>
            Represents a registry class that handles all class-level interception operations for all modified types.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current method call.</param>
      <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be used to wrap a method call or method body.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.AddProvider(LinFu.AOP.Interfaces.IAroundInvokeProvider)">
      <summary>
            Adds an <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> to the list of provider instances.
            </summary>
      <param name="provider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.Clear">
      <summary>
            Clears the list of <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.FieldInterceptionContext">
      <summary>
            Represents a class that describes the state of a field just as it is being intercepted by a <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptor" />.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptionContext.#ctor(System.Object,System.Reflection.MethodBase,System.Reflection.FieldInfo,System.Type)">
      <summary>
            Initializes a new instance of the FieldInterceptionContext class.
            </summary>
      <param name="target">The target that hosts the given field.</param>
      <param name="targetMethod">The method that accessed the target field.</param>
      <param name="targetField">The field currently being accessed by the target method.</param>
      <param name="hostType">The type that hosts the target field.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.Target">
      <summary>
            Gets a value indicating the target instance that is attached to the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.TargetMethod">
      <summary>
            Gets a value indicating the host method that is currently accessing the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.TargetField">
      <summary>
            Gets a value indicating the field that is currently being accessed by the target method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.HostType">
      <summary>
            Gets a value indicating the <see cref="T:System.Type" /> that holds the target field.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.TypeActivationContext">
      <summary>
            Represents an <see cref="T:LinFu.AOP.Interfaces.ActivationContext" /> that can be used to instantiate a given type
            and be used to describe the method that invoked the instantiation operation as well as specify the object
            instance that invoked the instantiation itself.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivationContext.#ctor(System.Object,System.Reflection.MethodBase,System.Type,System.Object[])">
      <summary>
            Initializes a new instance of the MethodActivationContext class.
            </summary>
      <param name="target">The object instance that initiated the activation request.</param>
      <param name="targetMethod">The method where the activation was invoked.</param>
      <param name="concreteType">The type to be constructed.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.TypeActivationContext.Target">
      <summary>
            Gets the value indicating the object instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.TypeActivationContext.TargetMethod">
      <summary>
            Gets the value indiating the <see cref="T:System.Reflection.MethodBase" /> instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptionHost">
      <summary>
            Represents a type that has been modified to intercept field getters and setters.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionHost.FieldInterceptor">
      <summary>
            Gets or sets the value indicating the interceptor that will handle field getters and setters.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Tasks.PostWeaveTask">
      <summary>
            Represents an MSBuild task for LinFu.AOP that allows users to inject an aspect framework into their applications
            at postbuild time.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Tasks.PostWeaveTask.Execute">
      <summary>
            Executes the postweaver.
            </summary>
      <returns>Returns <c>true</c> if the operation succeeded. Otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.TargetFile">
      <summary>
            Gets or sets the value indicating the full path and filename of the target assembly.
            </summary>
      <value>The target assembly filename.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.OutputFile">
      <summary>
            Gets or sets the value indicating the full path and filename of the output assembly.
            </summary>
      <value>The output assembly filename.</value>
      <remarks>This field is optional; if blank, the default value will be the same value as the <see cref="P:LinFu.AOP.Tasks.PostWeaveTask.TargetFile" /> property.</remarks>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllMethodCalls">
      <summary>
            Gets or sets the value indicating whether or not third party method calls should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not third party method call interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllMethodBodies">
      <summary>
            Gets or sets the value indicating whether or not method bodies should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not method body interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllNewInstances">
      <summary>
            Gets or sets the value indicating whether or not new instances should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not new instance interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllFields">
      <summary>
            Gets or sets the value indicating whether or not field reads and writes should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not field reads and writes should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllExceptions">
      <summary>
            Gets or sets the value indicating whether or not thrown exceptions should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not exception interception should be enabled.</value>
    </member>
    <member name="T:LinFu.Finders.Interfaces.ICriteria`1">
      <summary>
            Represents a class that describes the search criteria
            for a given item <typeparamref name="T">type</typeparamref>.
            </summary>
      <typeparam name="T">The target item type.</typeparam>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Type">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Finders.Interfaces.CriteriaType" />
            of the current <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Predicate">
      <summary>
            The condition that will determine whether or not
            the target item matches the criteria.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Weight">
      <summary>
            Gets or sets a value indicating the weight of the given <see cref="P:LinFu.Finders.Interfaces.ICriteria`1.Predicate" />.
            </summary>
    </member>
    <member name="T:LinFu.Finders.Criteria`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> interface.
            </summary>
      <typeparam name="T">The type of item to test.</typeparam>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Type">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Finders.Interfaces.CriteriaType" />
            of the current <see cref="T:LinFu.Finders.Criteria`1" />.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Predicate">
      <summary>
            The condition that will determine whether or not
            the target item matches the criteria.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Weight">
      <summary>
            The weight of the given <see cref="P:LinFu.Finders.Criteria`1.Predicate" />.
            </summary>
    </member>
    <member name="T:LinFu.Finders.FinderExtensions">
      <summary>
            A class that adds fuzzy search support to <see cref="T:System.Collections.Generic.IList`1" /> instances.
            </summary>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},LinFu.Finders.Interfaces.ICriteria{``0})">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="criteria">The criteria to test against each item in the list.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean},LinFu.Finders.Interfaces.CriteriaType)">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
      <param name="criteriaType">The <see cref="T:LinFu.Finders.Interfaces.CriteriaType" /> to associate with the predicate.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean},LinFu.Finders.Interfaces.CriteriaType,System.Int32)">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
      <param name="criteriaType">The <see cref="T:LinFu.Finders.Interfaces.CriteriaType" /> to associate with the predicate.</param>
      <param name="weight">The weight of the predicate value expressed in the number of tests that will be counted for/against the target item as a result of the predicate.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.Add``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},``0)">
      <summary>
            Adds an item to a fuzzy list.
            </summary>
      <typeparam name="T">The type of the item being added.</typeparam>
      <param name="list">The fuzzy list that will contain the new item.</param>
      <param name="item">The item being added.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.BestMatch``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}})">
      <summary>
            Returns the FuzzyItem with the highest confidence score in a given
            <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> list.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="list">The fuzzy list that contains the list of possible matches.</param>
      <returns>The item with the highest match.</returns>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.Reset``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}})">
      <summary>
            Resets the scores of all fuzzy items in the current list.
            </summary>
      <typeparam name="TItem">The target item type.</typeparam>
      <param name="list">The fuzzy list itself.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AsFuzzyList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts a list into a list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> objects.
            </summary>
      <typeparam name="TItem">The item type will be used in the fuzzy search.</typeparam>
      <param name="items">The target list to be converted.</param>
      <returns>A fuzzy list containing the elements from the given list.</returns>
    </member>
    <member name="T:LinFu.Finders.Interfaces.IFuzzyItem`1">
      <summary>
            Represents a search item in a fuzzy search list.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:LinFu.Finders.Interfaces.IFuzzyItem`1.Test(LinFu.Finders.Interfaces.ICriteria{`0})">
      <summary>
            Tests if the current item matches the given
            <paramref name="criteria" />.
            </summary>
      <param name="criteria">The <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> that determines whether or not the <see cref="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Item" /> meets a particular description.</param>
    </member>
    <member name="M:LinFu.Finders.Interfaces.IFuzzyItem`1.Reset">
      <summary>
            Resets the item back to its initial state.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Confidence">
      <summary>
            Reports the probability of a match
            based on the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />
            that has been tested so far. 
            
            A value of 1.0 indicates a 100% match;
            A value of 0.0 equals a zero percent match.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Item">
      <summary>
            Gets the target item.
            </summary>
    </member>
    <member name="T:LinFu.Finders.FuzzyItem`1">
      <summary>
            Represents the default implementation of a weighted item in
            a fuzzy list.
            </summary>
      <typeparam name="T">The item type to be tested.</typeparam>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.#ctor(`0)">
      <summary>
            Initializes the <see cref="T:LinFu.Finders.FuzzyItem`1" /> class with the given <paramref name="item" />.
            </summary>
      <param name="item">An instance of the <typeparamref name="T">item type</typeparamref> that will be tested.</param>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.Test(LinFu.Finders.Interfaces.ICriteria{`0})">
      <summary>
            Tests if the current item matches the given
            <paramref name="criteria" />.
            </summary>
      <param name="criteria">The <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> that determines whether or not the <see cref="P:LinFu.Finders.FuzzyItem`1.Item" /> meets a particular description.</param>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.Reset">
      <summary>
            Resets the item back to its initial state.
            </summary>
    </member>
    <member name="P:LinFu.Finders.FuzzyItem`1.Confidence">
      <summary>
            Reports the probability of a match
            based on the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />
            that has been tested so far. 
            
            A value of 1.0 indicates a 100% match;
            A value of 0.0 equals a zero percent match.
            </summary>
    </member>
    <member name="P:LinFu.Finders.FuzzyItem`1.Item">
      <summary>
            Gets the target item.
            </summary>
    </member>
    <member name="T:LinFu.Finders.Interfaces.CriteriaType">
      <summary>
            The enumeration that determines how a <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> instance should
            be handled if the criteria test fails.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Standard">
      <summary>
            A failure in a criteria test will result in a lower weighted
            score for a target item.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Optional">
      <summary>
            A failure in a criteria test will be ignored, and hence,
            the criteria will be optional.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Critical">
      <summary>
            A failure in a criteria test will cause all previous and remaining
            tests against the criteria to fail.
            </summary>
    </member>
    <member name="T:LinFu.Finders.PredicateExtensions">
      <summary>
            A class that adds logical extensions to the <see cref="T:System.Func`2" /> predicate
            class.
            </summary>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.Or``1(System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
      <summary>
            Logically ORs two <see cref="T:System.Func`2" /> predicates together.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="left">The left hand predicate.</param>
      <param name="right">The right hand predicate.</param>
      <returns>A predicate that will return <c>true</c> if and only if one of the given predicates is <c>true</c>; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.And``1(System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
      <summary>
            Logically ANDs two <see cref="T:System.Func`2" /> predicates together.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="left">The left hand predicate.</param>
      <param name="right">The right hand predicate.</param>
      <returns>A predicate that will return <c>true</c> if and only if both of the given predicates are <c>true</c>; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.Inverse``1(System.Func{``0,System.Boolean})">
      <summary>
            Logically negates a single predicate.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="predicate">The predicate to negate.</param>
      <returns>Returns <c>true</c> if the given predicate is <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryAttribute">
      <summary>
            An attribute that marks a type as a custom factory.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.FactoryAttribute.ArgumentTypes">
      <summary>
            The additional parameters supported by the custom factory.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.FactoryAttribute.ServiceName">
      <summary>
            The service name that will be associated
            with the service type.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttribute.#ctor(System.Type)">
      <summary>
            Marks a target type as a custom factory
            that can create object instances that
            can implement the <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">The service type to create.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.FactoryAttribute.ServiceType">
      <summary>
            Gets the service type that can be created
            using the factory instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IContainer">
      <summary>
            An inversion of control container interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.AddFactory(System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The service type to associate with the factory</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be responsible for creating the service instance</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.Contains(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not the container can create
            the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The type of service used to determine whether or not the given service can actually be created</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>A <see cref="T:System.Boolean">boolean</see> value that indicates whether or not the service exists.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.GetService(System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a null value.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IContainer.AvailableServices">
      <summary>
            The list of services currently available inside the container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors">
      <summary>
            Determines whether or not a container will throw an exception
            if the requested service is not found.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactory">
      <summary>
            Allows an object to create its own service instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactoryRequest">
      <summary>
            Represents the parameters made to a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance during
            a <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method call.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.Container">
      <summary>
            Gets or sets the value indicating the service container that made the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.ServiceName">
      <summary>
            Gets the value indicating the service name.
            </summary>
      <remarks>A null service name indicates that no service name was given during the request.</remarks>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.ServiceType">
      <summary>
            Gets the value indicating the requested service type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.Arguments">
      <summary>
            Gets the value indicating the additional arguments given in the factory request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.IInitialize">
      <summary>
            Represents service classes that need to be initialized
            every time a particular <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance creates that type.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ImplementsAttribute">
      <summary>
            The attribute used to specify how a service should be implemented
            in addition to its instancing behavior.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.ImplementsAttribute.ServiceName">
      <summary>
            The name to associate with the given service.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ImplementsAttribute.#ctor(System.Type)">
      <summary>
            Allows users to add services to a container using a 
            given <paramref name="serviceType">service type</paramref>.
            </summary>
      <remarks>By default, each service will be created once per request.</remarks>
      <param name="serviceType">The <see cref="T:System.Type" /> of service to implement.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ImplementsAttribute.#ctor(System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Allows users to add services to a container using a 
            given <paramref name="serviceType">service type</paramref> and 
            <paramref name="lifeCycleType">lifecycle type</paramref>.
            </summary>
      <param name="serviceType">The <see cref="T:System.Type" /> of service to implement.</param>
      <param name="lifeCycleType">The instancing behavior to use with this implementation.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.ImplementsAttribute.ServiceType">
      <summary>
            The type of service that will be implemented.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.ImplementsAttribute.LifecycleType">
      <summary>
            The instancing behavior of the service instance.        
            </summary>
      <seealso cref="P:LinFu.IoC.Configuration.ImplementsAttribute.LifecycleType" />
    </member>
    <member name="T:LinFu.IoC.Interfaces.IPostProcessor">
      <summary>
            Represents a class that can inspect or modify service requests
            from a given container once a service is created.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IPostProcessor.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Allows a <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance
            to inspect or modify the result of a service request.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" />
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> created as a result of the container operation.</param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IPreProcessor">
      <summary>
            Represents a class that can inspect or modify service requests
            from a given container before a service is created.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IPreProcessor.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Allows a <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance
            to inspect or modify the result of a service request
            just before the service is instantiated.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" />
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> instance that describes the nature of the service that needs to be created. </param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceContainer">
      <summary>
            An inversion of control container that supports
            named services.
            </summary>
      <seealso name="IContainer" />
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.AddFactory(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.Contains(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a service can be created using
            the given <paramref name="serviceName">service name</paramref>
            and <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that the factory type must support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.GetService(System.String,System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceContainer.PreProcessors">
      <summary>
            The list of preprocessors that will handle
            every service request before each actual service is created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceContainer.PostProcessors">
      <summary>
            The list of postprocessors that will handle every
            service request result.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceInfo">
      <summary>
            A class that describes a single service
            provided by a container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ArgumentTypes">
      <summary>
            Gets a value indicating the list of arguments required by this particular service.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceRequest">
      <summary>
            Represents a class that describes the context of a service request made to a service container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ActualArguments">
      <summary>
            Gets or sets the value indicating the actual arguments that
            will be used for the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ProposedArguments">
      <summary>
            Gets the value indicating the original arguments that
            were given during the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ProposedFactory">
      <summary>
            Gets the value indicating the original <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ActualFactory">
      <summary>
            Gets or sets the value indicating the actual <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceRequestResult">
      <summary>
            Represents the results returned when a service request
            is made against an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.OriginalResult">
      <summary>
            The raw object reference created by the container itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ActualResult">
      <summary>
            The result that will be returned from the container
            instead of the <see cref="P:LinFu.IoC.Interfaces.IServiceRequestResult.OriginalResult" />. 
            
            If this property is null, then the original result will be used.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.AdditionalArguments">
      <summary>
            Gets the value indicating the additional arguments that
            were used during the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.LifecycleType">
      <summary>
            An enumeration that denotes the instance behavior
            of a particular object reference.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.OncePerRequest">
      <summary>
            This means that a new object instance 
            will be created on each call.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.OncePerThread">
      <summary>
            This means that a new object instance 
            will be created only once per thread.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.Singleton">
      <summary>
            This means that only a single object instance
            will ever be created in spite of the number of
            subsequent requests for a new object instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.CompositePostProcessor">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> type that processes multiple <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances at once.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CompositePostProcessor.#ctor(System.Collections.Generic.IEnumerable{LinFu.IoC.Interfaces.IPostProcessor})">
      <summary>
            Initializes the type using the given <paramref name="postProcessors" />.
            </summary>
      <param name="postProcessors">The list of <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances that will be handled by this type.</param>
    </member>
    <member name="M:LinFu.IoC.CompositePostProcessor.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            A method that passes every request result made
            to the list of postprocessors.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the result of the service request.</param>
      <returns>A <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> representing the results returned as a result of the postprocessors.</returns>
    </member>
    <member name="T:LinFu.IoC.CompositePreProcessor">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> type that processes multiple <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances at once.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CompositePreProcessor.#ctor(System.Collections.Generic.IEnumerable{LinFu.IoC.Interfaces.IPreProcessor})">
      <summary>
            Initializes the type using the given <paramref name="preProcessors" />.
            </summary>
      <param name="preProcessors">The list of <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances that will be handled by this type.</param>
    </member>
    <member name="M:LinFu.IoC.CompositePreProcessor.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            A method that passes every request result made
            to the list of preprocessors.
            </summary>
      <param name="request">The parameter that describes the context of the service request.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IContainerActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type using a given
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IContainerActivationContext.Container">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            that will instantiate the <see cref="P:LinFu.AOP.Interfaces.IActivationContext.TargetType" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ContainerActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type using a given
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ContainerActivationContext.#ctor(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Initializes the class with the given parameters.
            </summary>
      <param name="concreteType">The type to be instantiated.</param>
      <param name="container">The container that will be used to instantiate the target type.</param>
      <param name="additionalArguments">The additional arguments that must be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.ContainerActivationContext.Container">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            that will instantiate the <see cref="P:LinFu.AOP.Interfaces.IActivationContext.TargetType" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.DefaultActivator">
      <summary>
            Represents a class that can instantiate object instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.DefaultActivator.CreateInstance(LinFu.IoC.Configuration.Interfaces.IContainerActivationContext)">
      <summary>
            Creates an object instance.
            </summary>
      <returns>A valid object instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.DefaultActivator.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the default services.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.InjectAttribute">
      <summary>
            The attribute used to mark a property for autoinjection.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.PostProcessorAttribute">
      <summary>
            Marks a target type as an <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
            instance that can be injected into a
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.PreprocessorAttribute">
      <summary>
            Marks a target type as an <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" />
            instance that can be injected into a
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1">
      <summary>
            Represents a class that is responsible for generating methods
            from other existing methods.
            </summary>
      <typeparam name="TMethod">The method type to generate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Creates a method from the <paramref name="existingMethod" />.
            </summary>
      <param name="existingMethod">The method that will be used to define the new method.</param>
      <returns>A method based on the old method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMethodBuilder`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1" /> interface.
            </summary>
      <typeparam name="TMethod">The method type to generate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Creates a method from the <paramref name="existingMethod" />.
            </summary>
      <param name="existingMethod">The method that will be used to define the new method.</param>
      <returns>A method based on the old method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.PushMethodArguments(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
      <summary>
            Pushes the method arguments onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="targetMethod">The target method that will be invoked.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.GetParameterList(`0,System.Type[])">
      <summary>
            Determines the parameter types of the dynamically generated method.
            </summary>
      <param name="existingMethod">The target method.</param>
      <param name="parameterTypes">The target method argument types.</param>
      <returns>The list of <see cref="T:System.Type" /> objects that describe the signature of the method to generate.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.PushInstance(System.Reflection.Emit.ILGenerator,`0)">
      <summary>
            Pushes the method target onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> that belongs to the method body.</param>
      <param name="method">The current method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.GetReturnType(`0)">
      <summary>
            Determines the return type from the target <paramref name="method" />.
            </summary>
      <param name="method">The target method itself.</param>
      <returns>The method return type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.EmitCall(System.Reflection.Emit.ILGenerator,`0)">
      <summary>
            Emits the instruction to call the target <paramref name="method" /></summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="method">The method that will be invoked.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1">
      <summary>
            Represents a type that can invoke a method
            using a given set of method arguments.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1.Invoke(System.Object,`0,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" />
            using the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target object instance.</param>
      <param name="targetMethod">The target method to invoke.</param>
      <param name="arguments">The arguments to be used with the method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorInvoke">
      <summary>
            A class that invokes constructor instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorInvoke.Invoke(System.Object,System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" /> constructor
            using the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target object instance.</param>
      <param name="targetMethod">The target method to invoke.</param>
      <param name="arguments">The arguments to be used with the method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorMethodBuilder">
      <summary>
            A method builder that generates dynamic methods using existing constructors.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorMethodBuilder.GetReturnType(System.Reflection.ConstructorInfo)">
      <summary>
            Returns the declaring type of the target constructor.
            </summary>
      <param name="constructor">
      </param>
      <returns>The declaring type of the target constructor.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorMethodBuilder.EmitCall(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
      <summary>
            Emits an instruction that instantiates the type associated with the
            <paramref name="constructor" />.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="constructor">The target constructor.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IConstructorArgumentResolver">
      <summary>
            Represents a type that determines the method arguments that should be used for a given constructor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IConstructorArgumentResolver.GetConstructorArguments(System.Reflection.ConstructorInfo,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Determines the parameter values that should be used for a given constructor.
            </summary>
      <param name="constructor">The target constructor.</param>
      <param name="container">The host container instance.</param>
      <param name="additionalArguments">The list of additional arguments that should be combined with the arguments from the container.</param>
      <returns>A list of arguments that will be used for the given constructor.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.INamedType">
      <summary>
            Represents a named type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.INamedType.Name">
      <summary>
            Gets or sets a value indicating the name that will be associated with the current type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.INamedType.Type">
      <summary>
            Gets or sets the value indicating the current target type.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.NamedType">
      <summary>
            Represents a named type.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.NamedType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.IoC.Configuration.NamedType" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.NamedType.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.IoC.Configuration.NamedType" /> class.
            </summary>
      <param name="currentType">The current type.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.NamedType.#ctor(System.Reflection.ParameterInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.IoC.Configuration.NamedType" /> class.
            </summary>
      <param name="parameter">The target parameter.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.NamedType.#ctor(System.Reflection.PropertyInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.IoC.Configuration.NamedType" /> class.
            </summary>
      <param name="property">The target property.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.NamedType.Name">
      <summary>
            Gets or sets a value indicating the name that will be associated with the current type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.NamedType.Type">
      <summary>
            Gets or sets the value indicating the current target type.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Resolvers.ConstructorArgumentResolver">
      <summary>
            Represents a class that determines the method arguments that should be used for a given constructor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.ConstructorArgumentResolver.GetConstructorArguments(System.Reflection.ConstructorInfo,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Determines the parameter values that should be used for a given constructor.
            </summary>
      <param name="constructor">The target constructor.</param>
      <param name="container">The host container instance.</param>
      <param name="additionalArguments">The list of additional arguments that should be combined with the arguments from the container.</param>
      <returns>A list of arguments that will be used for the given constructor.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.ConstructorArgumentResolver.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the default services.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.ConstructorArgumentResolver.GetMissingParameterTypes(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Determines which parameter types need to be supplied to invoke a particular
            <paramref name="constructor" />  instance.
            </summary>
      <param name="constructor">The target constructor.</param>
      <param name="additionalArguments">The additional arguments that will be used to invoke the constructor.</param>
      <returns>The list of parameter types that are still missing parameter values.</returns>
    </member>
    <member name="T:LinFu.IoC.ContainerExtensions">
      <summary>
            A class that adds generics support to existing 
            <see cref="T:LinFu.IoC.Interfaces.IContainer" /> and <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,LinFu.Reflection.IAssemblyLoader,System.String,System.String,LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>
            using a custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="assemblyLoader">The custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will be used to load the target assemblies from disk.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
      <param name="customLoader">The custom loader that will be used to load the container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,LinFu.Reflection.IAssemblyLoader,System.String,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>
            using a custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="assemblyLoader">The custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will be used to load the target assemblies from disk.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.String,LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
      <param name="customLoader">The custom loader that will be used to load the container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFromBaseDirectory(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the application base directory.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreateFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <remarks>
            This method only performs constructor injection on the target type. If you need any other form of injection (such as property injection), you'll need to 
            register your type and instantiate it with the <see cref="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])" /> method.
            </remarks>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoLoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.String)">
      <summary>
            Automatically loads assemblies from the given <paramref name="directory" /> whenever an assembly
            matching the given <paramref name="fileSpec" /> is dropped into the given directory.
            </summary>
      <param name="container">The service container that will automatically be configured whenever a file change is detected.</param>
      <param name="directory">The target directory.</param>
      <param name="fileSpec">The assembly file pattern.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.Reflection.Assembly)">
      <summary>
            Loads an existing <paramref name="assembly" /> into the container.
            </summary>
      <param name="container">The target container to be configured.</param>
      <param name="assembly">The assembly to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.CreateDefaultContainerLoader(LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Generates the default <see cref="T:LinFu.IoC.Configuration.AssemblyContainerLoader" /> for a <see cref="T:LinFu.IoC.Configuration.Loader" /> class instance.
            </summary>
      <param name="loader">The loader that will load the target container.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Configuration.AssemblyContainerLoader" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomPropertyInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark properties
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark properties for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomMethodInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark methods
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark method for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomFieldInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark fields
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark fields for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            with the default services.
            </summary>
      <param name="container">
      </param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreate(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreate``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Automatically instantiates a <typeparamref name="T" /> type
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <typeparam name="T">The type to instantiate.</typeparam>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type's constructors.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.PostProcess(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object,System.Object[])">
      <summary>
            Postprocesses an object instance as if it were created from the target <paramref name="container" />.
            </summary>
      <param name="container">The container that will postprocess the target <paramref name="instance" />.</param>
      <param name="concreteType">The type being processed.</param>
      <param name="instance">The target instance to be processed.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreateInternal(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <remarks>
            This method only performs constructor injection on the target type. If you need any other form of injection (such as property injection), you'll need to 
            register your type and instantiate it with the <see cref="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])" /> method.
            </remarks>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddDefaultServices(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the container with the minimum required services.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Creates an instance of <typeparamref name="T" />
            using the given <paramref name="container" />.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
      <param name="container">The container that will instantiate the service.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.IServiceInfo,System.Object[])">
      <summary>
            Instantiates a service that matches the <paramref name="info">service description</paramref>.
            </summary>
      <param name="container">The container that will instantiate the service.</param>
      <param name="info">The description of the requested service.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Object[])">
      <summary>
            Creates an instance of <typeparamref name="T" />
            using the given <paramref name="container" />.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
      <param name="container">The container that will instantiate the service.</param>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Type)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Registers the <paramref name="serviceTypeToRegisterAsSelf">service type</paramref>
            as both the implementing type and the service type using the given <paramref name="lifecycle" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceTypeToRegisterAsSelf">The service type that will be registered as both the service type and the implementing type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Registers the <paramref name="serviceTypeToRegisterAsSelf">service type</paramref>
            as both the implementing type and the service type.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceTypeToRegisterAsSelf">The service type that will be registered as both the service type and the implementing type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Object)">
      <summary>
            Registers an existing service instance with the container using the given
            <paramref name="serviceName" /> and <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container instance.</param>
      <param name="serviceName">The service name that will be associated with the service instance.</param>
      <param name="serviceType">The target service type.</param>
      <param name="serviceInstance">The actual service instance that will represent the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object)">
      <summary>
            Registers an existing service instance with the container using the given
            <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container instance.</param>
      <param name="serviceType">The target service type.</param>
      <param name="serviceInstance">The actual service instance that will represent the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <paramref name="serviceType" />.</param>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,LinFu.IoC.Interfaces.IFactory{``0})">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <typeparamref name="T">service type</typeparamref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="container">The container that will hold the factory instance.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory``1(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.IFactory{``0})">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <typeparamref name="T">service type</typeparamref>.
            </summary>
      <param name="container">The container that will hold the factory instance.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it with the given
            <paramref name="serviceName" /> and <paramref name="serviceType" /></summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The service name.</param>
      <param name="serviceType">The service type.</param>
      <param name="factory">The factory instance that will be responsible for creating the service itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it with the given
            <paramref name="serviceType" /></summary>
      <param name="container">The target container.</param>
      <param name="serviceType">The service type.</param>
      <param name="factory">The factory instance that will be responsible for creating the service itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddDefaultFactory(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Registers the <paramref name="factory" /> as the default factory instance
            that will be used if no other factory can be found for the current <paramref name="serviceType" />.
            </summary>
      <param name="container">The host container.</param>
      <param name="serviceType">The service type that will be created by the default factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used if no other factories can create the given service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``2(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.MulticastDelegate)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="serviceType">The service type that will be implemented.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``3(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``5(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2,``3,``4})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T3">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T4">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``4(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2,``3})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T3">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0},LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> and <paramref name="lifecycleType" />
            to instantiate the service instance.
            </summary>
      <typeparam name="T">The service type itself.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="lifecycleType">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0},LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> and <paramref name="lifecycleType" />
            to instantiate the service instance.
            </summary>
      <typeparam name="T">The service type itself.</typeparam>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="lifecycleType">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,``0)">
      <summary>
            Adds an existing service instance to the container.
            </summary>
      <typeparam name="T">The type of service being added.</typeparam>
      <param name="container">The container that will hold the service instance.</param>
      <param name="instance">The service instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,``0)">
      <summary>
            Adds an existing service instance to the container and
            associates it with the <paramref name="serviceName" />.
            </summary>
      <typeparam name="T">The type of service being added.</typeparam>
      <param name="container">The container that will hold the service instance.</param>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="instance">The service instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetServices``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Returns all the services in the container that match the given
            <typeparamref name="T">service type</typeparamref>.
            </summary>
      <typeparam name="T">The type of service to return.</typeparam>
      <param name="container">The target container.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>The list of services that implement the given service type.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetServices(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IServiceInfo,System.Boolean},System.Object[])">
      <summary>
            Returns a list of services that match the given <paramref name="condition" />.
            </summary>
      <param name="condition">The predicate that determines which services should be returned.</param>
      <returns>A list of <see cref="T:LinFu.IoC.Interfaces.IServiceInstance" /> objects that describe the services returned as well as provide a reference to the resulting services themselves.</returns>
      <param name="container">the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Object[])">
      <summary>
            Determines whether or not the container can instantiate the given <paramref name="serviceName" />
            and <paramref name="serviceType" /> using the given <paramref name="sampleArguments" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The name of the requested service.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="sampleArguments">The potential arguments for the service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Determines whether or not the container contains a service that matches
            the given <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceType">The requested service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type)">
      <summary>
            Determines whether or not the container contains a service that matches
            the given <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The requested service name.</param>
      <param name="serviceType">The requested service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IServiceInfo,System.Boolean})">
      <summary>
            Determines whether or not a container contains services that match
            the given <paramref name="condition" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="condition">The predicate that will be used to determine whether or not the requested services exist.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoPropertyInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic property injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoMethodInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic method injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoFieldInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic field injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoInjectionFor``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic dependency injection for members that match the specific
            <typeparamref name="TMember" /> type.
            </summary>
      <typeparam name="TMember">The member injection type to disable.</typeparam>
      <param name="container">The target container.</param>
    </member>
    <member name="T:LinFu.IoC.FluentExtensions">
      <summary>
            A class that adds fluent syntax support to <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Inject``1(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Injects a <typeparamref name="TService" /> type
            into a <paramref name="container" /> using the
            given <paramref name="serviceName" /></summary>
      <typeparam name="TService">The type of service to inject.</typeparam>
      <param name="container">The container that will hold the actual service service instance.</param>
      <param name="serviceName">The name of the service to create.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IUsingLambda`1" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Inject``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects a <typeparamref name="TService" /> type
            into a <paramref name="container" />.
            </summary>
      <typeparam name="TService">The type of service to inject.</typeparam>
      <param name="container">The container that will hold the actual service service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IUsingLambda`1" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Initialize``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes services that match the given <typeparamref name="TService" /> type.
            </summary>
      <typeparam name="TService">The service type to initialize.</typeparam>
      <param name="container">The container that will create the service itself.</param>
      <returns>A <see cref="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1" /> instance. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Initialize``1(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Initializes services that match the given <paramref name="serviceName" /> and <typeparamref name="TService" /> type.
            </summary>
      <typeparam name="TService">The service type to initialize.</typeparam>
      <param name="container">The container that will create the service itself.</param>
      <param name="serviceName">The name of the service to initialize.</param>
      <returns>A <see cref="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1" /> instance. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.CreateAdapter``1(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0})">
      <summary>
            Converts a <see cref="T:System.Func`4" />
            lambda into an equivalent <see cref="T:System.Func`4" />
            instance.
            </summary>
      <typeparam name="TService">The type of service to create.</typeparam>
      <param name="func">The lambda function to be converted.</param>
      <returns>The equivalent <see cref="T:System.Func`2" />
            that delegates its calls back to the <paramref name="func" /> lambda function.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ResolutionExtensions">
      <summary>
            Adds methods that extend LinFu.IoC to support automatic constructor resolution.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.MustExistInContainer(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific parameter type
            exists in a container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ExistsAsEnumerableSetOfServices(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific type is actually
            a list of services that can be created from a given container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists as a list of services in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ExistsAsServiceArray(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific type is actually
            a list of services that can be created from a given container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists as a list of services in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ResolveArgumentsFrom(System.Reflection.MethodBase,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Builds an argument list for the <paramref name="method" />
            using the given <paramref name="container" /> instance.
            </summary>
      <param name="method">The method that will be used to instantiate an object instance.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <returns>An array of objects to be used with the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ResolveFrom(LinFu.IoC.Configuration.Interfaces.IArgumentResolver,System.Reflection.MethodBase,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Builds an argument list for the target <paramref name="method" /> from
            services embedded inside the <paramref name="container" /> instance.
            </summary>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> instance that will determine the method arguments.</param>
      <param name="method">The target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects to be used with the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.Cast(System.Collections.IEnumerable,System.Type)">
      <summary>
            Casts an <see cref="T:System.Collections.IEnumerable" /> set of items into an array of
            <paramref name="targetElementType" /> items.
            </summary>
      <param name="items">The items being converted.</param>
      <param name="targetElementType">The element type of the resulting array.</param>
      <returns>An array of items that match the <paramref name="targetElementType" />.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.Cast``1(System.Collections.IEnumerable)">
      <summary>
            Performs a strongly typed cast against an <see cref="T:System.Collections.IEnumerable" /> instance.
            </summary>
      <typeparam name="T">The target element type.</typeparam>
      <param name="items">The list of items being converted.</param>
      <returns>An array of items that match the <typeparamref name="T" /> element type.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder">
      <summary>
            Represents a class that can generate <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances 
            from a given service type, implementing type, and lifecycle.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Generates a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that can create the <paramref name="serviceType" />
            using the <paramref name="implementingType" /> and <paramref name="lifecycle" /> model.
            </summary>
      <param name="serviceType">The service type that will be created by the factory.</param>
      <param name="implementingType">The concrete type that will provide the implementation for the service type.</param>
      <param name="lifecycle">The instancing behavior of the given service type.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryBuilder">
      <summary>
            The default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="implementingType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="implementingType">The actual type that will implement the service.</param>
      <param name="lifecycle">The <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> that determines the lifetime of each instance being created.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactory(System.Type,System.Type,System.Type)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="actualType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="actualType">The actual type that will implement the service.</param>
      <param name="factoryType">The factory type that will instantiate the target service.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.GetActualType(System.Type,System.Type)">
      <summary>
            Determines the implementing concrete type from the given <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">The service type.</param>
      <param name="implementingType">The concrete class that will implement the service type.</param>
      <returns>The actual implementing type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactoryMethod(System.Type,System.Type)">
      <summary>
            A <c>private</c> method that creates the factory method delegate
            for use with a particular factory class.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
      <param name="serviceType">The service type being instantiated.</param>
      <param name="implementingType">The type that will provide the implementation for the actual service.</param>
      <returns>A factory method delegate that can create the given service.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactoryMethodInternal``2">
      <summary>
            A method that generates the actual lambda function that creates
            the new service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
      <typeparam name="TImplementation">The type that will provide the implementation for the actual service.</typeparam>
      <returns>A strongly-typed factory method delegate that can create the given service.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseContext`1">
      <summary>
            Represents a class that provides the most basic information
            for executing a fluent command against a 
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TService">
      </typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.ServiceType">
      <summary>
            The service type to be created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.ServiceName">
      <summary>
            The name of the service to be created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.Container">
      <summary>
            The actual <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            that ultimately will hold the service instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ActionContext`1">
      <summary>
            Represents the <c>internal</c> context class that will be used to 
            incrementally build enough information to initialize
            a specific <typeparamref name="TService" /> type once
            that service has been instantiated.
            </summary>
      <typeparam name="TService">The service type to be created.</typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.ActionContext`1.Action">
      <summary>
            The action that will be performed on an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance once the fluent command executes.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ActionPostProcessor`1">
      <summary>
            Represents a postprocessor that will execute
            the action associated with the given <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            instance every time the target container returns a 
            service with particular service name and service type.
            </summary>
      <typeparam name="TService">
      </typeparam>
    </member>
    <member name="T:LinFu.IoC.Configuration.IGenerateFactory`1">
      <summary>
            Represents a fluent class that allows
            users to create specific types of factories.
            </summary>
      <typeparam name="TService">The type of service being created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.AsSingleton">
      <summary>
            Creates a singleton factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.OncePerThread">
      <summary>
            Creates a once per thread factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.OncePerRequest">
      <summary>
            Creates a once per request factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
    </member>
    <member name="T:LinFu.IoC.Configuration.GenerateFactory`1">
      <summary>
            Represents a fluent class that allows
            users to create specific types of factories.
            </summary>
      <typeparam name="TService">The type of service being created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.#ctor(LinFu.IoC.Configuration.InjectionContext{`0})">
      <summary>
            Instantiates the class using the given
            <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.IoC.Configuration.InjectionContext`1" /> instance
            which will contain the information necessary to build a fluent command.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.AsSingleton">
      <summary>
            Creates a singleton factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.OncePerThread">
      <summary>
            Creates a once per thread factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.OncePerRequest">
      <summary>
            Creates a once per request factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.AddFactory(System.Func{System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0},LinFu.IoC.Interfaces.IFactory{`0}})">
      <summary>
            Adds a factory to the container by using the 
            <paramref name="createFactory" /> delegate to
            create the actual <see cref="T:LinFu.IoC.Interfaces.IFactory`1" />
            instance.
            </summary>
      <param name="createFactory">The delegate that will create the actual factory instance.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.InjectionContext`1">
      <summary>
            Represents the <c>internal</c> context class that will be used to 
            incrementally build enough information to inject a specific
            <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance into a container.
            </summary>
      <typeparam name="TService">The service type to be created.</typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.InjectionContext`1.FactoryMethod">
      <summary>
            The factory method that will be used to
            instantiate the actual <typeparamref name="TService" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1">
      <summary>
            Represents a fluent class that creates
            a method that initializes a <typeparamref name="TService" />
            instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1.With(System.Action{`0})">
      <summary>
            Initializes service instances with the given
            <paramref name="action" />.
            </summary>
      <param name="action">An <see cref="T:System.Action`1" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1.With(System.Action{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Uses an action delegate to initialize a given service using
            the given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> and <typeparamref name="TService" />
            instances.
            </summary>
      <param name="action">An <see cref="T:System.Func`2" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.PropertyInjectionLambda`1">
      <summary>
            Represents a fluent class that creates
            a method that initializes a <typeparamref name="TService" />
            instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.#ctor(LinFu.IoC.Configuration.ActionContext{`0})">
      <summary>
            Initializes the class with the <paramref name="context" />.
            </summary>
      <param name="context">The context that will be associated with the target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.With(System.Action{`0})">
      <summary>
            Initializes service instances with the given
            <paramref name="action" />.
            </summary>
      <param name="action">An <see cref="T:System.Action`1" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.With(System.Action{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Uses an action delegate to initialize a given service using
            the given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> and <typeparamref name="TService" />
            instances.
            </summary>
      <param name="action">An <see cref="T:System.Func`2" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.AddPostProcessor(LinFu.IoC.Configuration.ActionContext{`0})">
      <summary>
            Attaches the action associated with the <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            instance to the target container embedded within the <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            class itself.
            </summary>
      <param name="context">The context that will be associated with the target container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.IUsingLambda`1">
      <summary>
            Represents a fluent class that creates
            a factory method that will be used
            in instantiating a specific service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using``1">
      <summary>
            Creates a service instance using the
            concrete <typeparamref name="TConcrete" /> type 
            as the implementation for the <typeparamref name="TService" />
            type.
            </summary>
      <typeparam name="TConcrete">The concrete implementation that implements <typeparamref name="TService" />. This class must have a default constructor.</typeparam>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,System.Object[],`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.UsingLambda`1">
      <summary>
            Represents a fluent class that creates
            a factory method that will be used
            in instantiating a specific service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.#ctor(LinFu.IoC.Configuration.InjectionContext{`0})">
      <summary>
            Initializes the class using the given <paramref name="context" />.
            </summary>
      <param name="context">the <c>internal</c> context class that will be used to 
            incrementally build enough information to inject a specific
            <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance into a container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using``1">
      <summary>
            Creates a service instance using the
            concrete <typeparamref name="TConcrete" /> type 
            as the implementation for the <typeparamref name="TService" />
            type.
            </summary>
      <typeparam name="TConcrete">The concrete implementation that implements <typeparamref name="TService" />. This class must have a default constructor.</typeparam>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,System.Object[],`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Initializer`1">
      <summary>
            A class that initializes service instances that use
            the <see cref="T:LinFu.Reflection.IInitialize`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,`0})">
      <summary>
            Initializes the class with the given <paramref name="getSource" /> delegate.
            </summary>
      <param name="getSource">The functor that will obtain the object instance that will be used to initialize a given service.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Initializes every service that implements
            the <see cref="T:LinFu.Reflection.IInitialize`1" /> interface.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that contains the service instance to be initialized.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.Initialize(LinFu.Reflection.IInitialize{`0},`0)">
      <summary>
            Initializes the <paramref name="target" /> with the given <paramref name="source" /> instance.
            </summary>
      <param name="target">The target to initialize.</param>
      <param name="source">The instance that will be introduced to the <see cref="T:LinFu.Reflection.IInitialize`1" /> instance.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Initializer">
      <summary>
            A class that initializes service instances that use
            the <see cref="T:LinFu.IoC.Configuration.IInitialize" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer.#ctor">
      <summary>
            Initializes the class with the default settings.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.InitializerPlugin">
      <summary>
            A class that injects the <see cref="T:LinFu.IoC.Configuration.Initializer" /> postprocessor
            into every container that is created or loaded.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.InitializerPlugin.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            This override does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.InitializerPlugin.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects the <see cref="T:LinFu.IoC.Configuration.Initializer" /> postprocessor into
            the container.
            </summary>
      <param name="target">
      </param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1">
      <summary>
            An interface responsible for determining which methods
            should be injected.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Returns the list of <see cref="T:System.Reflection.MethodBase" /> objects
            that will be injected with arbitrary values.
            </summary>
      <param name="targetType">The target type that contains the target methods.</param>
      <returns>A set of methods that describe which methods that will injected.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1">
      <summary>
            Defines the basic behavior of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" /> interface.
            </summary>
      <typeparam name="TMember">The member type that will be filtered.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1" /> class.
            </summary>
      <param name="source">The host container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Returns the list of <typeparamref name="TMember" /> objects
            whose setters will injected with arbitrary values.
            </summary>
      <remarks>This implementation selects properties that are marked with the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />.</remarks>
      <param name="targetType">The target type that contains the target properties.</param>
      <returns>A set of properties that describe which parameters should be injected.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <typeparamref name="TMember" /> objects that pass the filter description.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.Filter(LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Determines which items should be injected from the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <param name="container">The source container that will supply the values for the selected members.</param>
      <param name="items">The list of properties that will be filtered.</param>
      <returns>A list of properties that will be injected.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedFieldInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns fields which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.#ctor">
      <summary>
            Initializes the class and uses the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            to specify which field should be automatically injected with
            services from the container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            to specify which fields should be automatically injected with
            services from the container.
            </summary>
      <param name="attributeType">The custom property attribute that will be used to mark properties for automatic injection.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.FieldInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedMethodInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns methods which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.#ctor">
      <summary>
            Initializes the class with the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" /> as the
            default injection attribute.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            as the custom injection attribute.
            </summary>
      <param name="attributeType">
      </param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Returns the methods that have the custom attribute type defined.
            </summary>
      <param name="targetType">The target type that contains the target methods.</param>
      <param name="container">The host container.</param>
      <returns>The list of methods that have the custom attribute type defined.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns properties which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.#ctor">
      <summary>
            Initializes the class and uses the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            to specify which properties should be automatically injected with
            services from the container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            to specify which properties should be automatically injected with
            services from the container.
            </summary>
      <param name="attributeType">The custom property attribute that will be used to mark properties for automatic injection.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.Filter(LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
      <summary>
            Determines which properties should be injected from the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <param name="container">The source container that will supply the property values for the selected properties.</param>
      <param name="properties">The list of properties to be filtered.</param>
      <returns>A list of properties that should be injected.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.PropertyInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IContainerPlugin">
      <summary>
            Represents an alias interface used for backward compatibility with LinFu IoC 1.0
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoMemberInjector`1">
      <summary>
            The base class that defines the behavior for automatically injecting service
            instances into type member instances.
            </summary>
      <typeparam name="TMember">
      </typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Inserts the <see cref="T:LinFu.IoC.Configuration.AutoPropertyInjector" /> class at the end
            of the PostProcessor chain.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Automatically injects service instances
            into properties as soon as they are initialized.
            </summary>
      <param name="result">The service request result that contains the service whose members will be injected with service instances.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.Inject(System.Object,`0,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <paramref name="member" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="member">The <typeparamref name="TMember" /> instance that will store the service instance.</param>
      <param name="argumentResolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.AutoInject(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Injects a member service dependency into a target service instance.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> that will be processed for injection.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoFieldInjector">
      <summary>
            A class that automatically injects fields using values
            provided by an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoFieldInjector.Inject(System.Object,System.Reflection.FieldInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects a field with values from a given container.
            </summary>
      <param name="target">The target object.</param>
      <param name="member">The <see cref="T:System.Reflection.FieldInfo" /> instance that will store the service instance.</param>
      <param name="argumentResolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which values will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process. Note: This parameter will be ignored by this override.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoMethodInjector">
      <summary>
            A class that automatically invokes methods using arguments
            derived from existing instances from within a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMethodInjector.Inject(System.Object,System.Reflection.MethodInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <see cref="T:System.Reflection.MethodInfo" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> instance that will store the service instance.</param>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoPropertyInjector">
      <summary>
            A class that automatically injects property dependencies into
            service instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoPropertyInjector.Inject(System.Object,System.Reflection.PropertyInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <see cref="T:System.Reflection.PropertyInfo" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="property">The <see cref="T:System.Reflection.PropertyInfo" /> instance that will store the service instance.</param>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector">
      <summary>
            A class that injects unnamed custom <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances into a given
            service container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector.#ctor(System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Initializes the class with the given service type and factory.
            </summary>
      <param name="serviceType">The service type that will be created by the factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to create the service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Injects the given factory into the target container.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> instance that describes the service that is currently being requested.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Injectors.NullMemberInjectionFilter`1">
      <summary>
            Represents a type of <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            that always returns an empty match.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.NullMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Always returns an empty list of injectable members.
            </summary>
      <param name="targetType">The type to be injected.</param>
      <returns>An empty list.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.PropertyInjectionFilter">
      <summary>
            An <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" /> implementation
            that automatically selects properties whose property types
            currently exist in the target container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.PropertyInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.InMemoryAssemblyLoader">
      <summary>
            An assembly loader that returns an existing
            <see cref="T:System.Reflection.Assembly" /> from memory.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.InMemoryAssemblyLoader.#ctor(System.Reflection.Assembly)">
      <summary>
            Initializes the class with an existing
            <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="targetAssembly">The target assembly.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext">
      <summary>
            Represents the data associated with a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> search.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.TypeArguments">
      <summary>
            Gets or sets the value indicating the type arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.Arguments">
      <summary>
            Gets or sets the value indicating the list of arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.ReturnType">
      <summary>
            Gets or sets the value indicating the <see cref="T:System.Type">return type</see> of the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1">
      <summary>
            Represents a class that determines which method best matches the
            services currently in the target container.
            </summary>
      <typeparam name="T">The method type to search.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1.GetBestMatch(System.Collections.Generic.IEnumerable{`0},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Determines which method best matches the
            services currently in the target container.
            </summary>
      <param name="items">The list of methods to search.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>Returns the method with the most resolvable parameters from the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderWithContainer`1">
      <summary>
            Represents a method finder that uses a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            during its method searches.
            </summary>
      <typeparam name="TMethod">
      </typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderWithContainer`1.Container">
      <summary>
            Gets the value indicating the service container that will be used in the
            method search.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.AssemblyContainerLoader">
      <summary>
            Represents a class that loads configuration information
            from a given assembly.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ITypeLoader">
      <summary>
            Generates one or more <see cref="T:System.Action`1" /> instances
            from a given source type so that it can be used
            against an <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryAttributeLoader">
      <summary>
            A class that injects custom <see cref="T:LinFu.IoC.Interfaces.IFactory" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory`1" />
            instances into an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.Load(System.Type)">
      <summary>
            Loads an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance
            into a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance using the given
            <paramref name="sourceType" />.
            </summary>
      <param name="sourceType">The input type from which one or more factories will be created.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be null.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not the current <paramref name="sourceType" />
            can be loaded.
            </summary>
      <param name="sourceType">The source type currently being loaded.</param>
      <returns>Returns <c>true</c> if the type is a class type; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.GetResults(System.Type,System.Collections.Generic.IEnumerable{LinFu.IoC.Configuration.FactoryAttribute},System.Func{LinFu.IoC.Interfaces.IFactoryRequest,System.Object})">
      <summary>
            Instantiates the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances associated with the <paramref name="sourceType" /> and
            adds those factories to the target container upon initialization.
            </summary>
      <param name="sourceType">The <see cref="T:System.Type" /> currently being inspected.</param>
      <param name="attributeList">The list of <see cref="T:LinFu.IoC.Configuration.FactoryAttribute" /> instances currently declared on on the source type.</param>
      <param name="getFactoryInstance">The functor that will be responsible for generating the factory instance.</param>
      <returns>A list of actions that will add the factories to the target container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.GetFactory(System.Type,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory},System.Collections.Generic.ICollection{System.Type})">
      <summary>
            Instantiates the given factory using the <paramref name="getStronglyTypedFactory">factory functor.</paramref></summary>
      <param name="currentServiceType">The service type that will be created by the factory.</param>
      <param name="getStronglyTypedFactory">The functor that will be responsible for creating the factory itself.</param>
      <param name="implementedInterfaces">The list of <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> interfaces that are implemented by the source type.</param>
      <returns>A valid factory instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader">
      <summary>
            A loader class that scans a type for <see cref="T:LinFu.IoC.Configuration.ImplementsAttribute" />
            attribute declarations and creates a factory for each corresponding 
            attribute instance.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IFactory" />
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.Load(System.Type)">
      <summary>
            Converts a given <see cref="T:System.Type" /> into
            a set of <see cref="T:System.Action`1" /> instances so that
            the <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance can be loaded
            with the given factories.
            </summary>
      <param name="sourceType">The input type from which one or more factories will be created.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be null.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not the current <paramref name="sourceType" />
            can be loaded.
            </summary>
      <param name="sourceType">The source type currently being loaded.</param>
      <returns>Returns <c>true</c> if the type is a class type; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="implementingType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="implementingType">The actual type that will implement the service.</param>
      <param name="lifecycle">The <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> that determines the lifetime of each instance being created.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loader">
      <summary>
            Represents a class that can dynamically configure
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instances at runtime.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loader.#ctor">
      <summary>
            Initializes the loader using the default values.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Loader.AssemblyLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance
            that will be used to load assemblies into memory.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.PostProcessorLoader">
      <summary>
            A class that automatically loads <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
            instances and configures a loader to inject those postprocessors
            into a container upon initialization.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PostProcessorLoader.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement the <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> interface before it can be loaded into memory.</remarks>
      <param name="inputType">The target type that might contain the target instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PostProcessorLoader.Load(System.Type)">
      <summary>
            Loads a set of <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances
            so that they can be loaded into a container upon initialization.
            </summary>
      <param name="inputType">The type that will be used to configure the target loader.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.PreProcessorLoader">
      <summary>
            A class that automatically loads <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" />
            instances and configures a loader to inject those postprocessors
            into a container upon initialization.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PreProcessorLoader.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement the <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> interface before it can be loaded into memory.</remarks>
      <param name="inputType">The target type that might contain the target instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PreProcessorLoader.Load(System.Type)">
      <summary>
            Loads a set of <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances
            so that they can be loaded into a container upon initialization.
            </summary>
      <param name="inputType">The type that will be used to configure the target loader.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodBuilder">
      <summary>
            A class that dynamically generates calls to a <see cref="T:System.Reflection.MethodInfo" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.PushInstance(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
      <summary>
            Pushes the method target onto the evaluation stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the method body.</param>
      <param name="method">The target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.PushMethodArguments(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
      <summary>
            Pushes the method arguments onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="targetMethod">The target method that will be invoked.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.GetReturnType(System.Reflection.MethodInfo)">
      <summary>
            Determines the return type from the target <paramref name="method" />.
            </summary>
      <param name="method">The target method itself.</param>
      <returns>The method return type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.GetParameterList(System.Reflection.MethodInfo,System.Type[])">
      <summary>
            Determines the parameter types of the dynamically generated method.
            </summary>
      <param name="existingMethod">The target method.</param>
      <param name="parameterTypes">The target method argument types.</param>
      <returns>The list of <see cref="T:System.Type" /> objects that describe the signature of the method to generate.</returns>
      <remarks>This override will add an additional parameter type to accomodate the method target.</remarks>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.EmitCall(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
      <summary>
            Emits the instruction to call the target <paramref name="method" /></summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="method">The method that will be invoked.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMethodInvoke`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the <paramref name="source">source service container.</paramref></summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will initialize this class.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.Invoke(System.Object,`0,System.Object[])">
      <summary>
            Instantiates an object instance with the <paramref name="targetMethod" />
            and <paramref name="arguments" />.
            </summary>
      <param name="target">The target object reference. In this particular case, this parameter will be ignored.</param>
      <param name="targetMethod">The target method.</param>
      <param name="arguments">The arguments to be used with the method.</param>
      <returns>An object reference that represents the method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.DoInvoke(System.Object,`0,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" /> with the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target instance.</param>
      <param name="originalMethod">The original method that describes the target method.</param>
      <param name="targetMethod">The actual method that will be invoked.</param>
      <param name="arguments">The method arguments.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.GenerateTargetMethod(`0)">
      <summary>
            Creates a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that will be used as the 
            factory method and stores it in the method cache.
            </summary>
      <param name="targetMethod">The constructor that will be used to instantiate the target type.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseMethodInvoke`1.MethodBuilder">
      <summary>
            Gets or sets the value indicating the method builder that will be used to
            create the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodFinderContext">
      <summary>
            Represents the data associated with a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> search.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinderContext.#ctor(System.Object[])">
      <summary>
            Initializes the context with the default values.
            </summary>
      <param name="arguments">The list of arguments that will be passed to the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinderContext.#ctor(System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Object},System.Type)">
      <summary>
            Initializes the context with the default values.
            </summary>
      <param name="typeArguments">The type arguments that will be used to construct the target method.</param>
      <param name="arguments">The list of arguments that will be passed to the target method.</param>
      <param name="returnType">The type that must be returned by the target method.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.TypeArguments">
      <summary>
            Gets or sets the value indicating the type arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.Arguments">
      <summary>
            Gets or sets the value indicating the list of arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.ReturnType">
      <summary>
            Gets or sets the value indicating the <see cref="T:System.Type">return type</see> of the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodInvoke">
      <summary>
            A class that invokes methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodInvoke.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodInvoke.DoInvoke(System.Object,System.Reflection.MethodInfo,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" /> with the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target instance.</param>
      <param name="originalMethod">The original method that describes the target method.</param>
      <param name="targetMethod">The actual method that will be invoked.</param>
      <param name="arguments">The method arguments.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IPropertySetter">
      <summary>
            A class responsible for setting property values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertySetter.Set(System.Object,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Sets the value of the <paramref name="targetProperty" />.
            </summary>
            /// <param name="target">The target instance that contains the property to be modified.</param><param name="targetProperty">The property that will store the given value.</param><param name="value">The value that will be assigned to the property.</param></member>
    <member name="T:LinFu.IoC.Configuration.PropertySetter">
      <summary>
            A class responsible for setting property values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertySetter.Set(System.Object,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Sets the value of the <paramref name="targetProperty" />.
            </summary>
      <param name="target">The target instance that contains the property to be modified.</param>
      <param name="targetProperty">The property that will store the given value.</param>
      <param name="value">The value that will be assigned to the property.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertySetter.GenerateSetter(System.Reflection.PropertyInfo)">
      <summary>
            Generates an <see cref="T:System.Action`2" /> delegate that will be used
            as the property setter for a particular type.
            </summary>
      <param name="targetProperty">The property that will be modified.</param>
      <returns>A property setter.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.RecursiveDependencyException">
      <summary>
            The exception thrown when a recursive dependency is detected
            inside a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.RecursiveDependencyException.#ctor(System.Collections.Generic.LinkedList{System.Type})">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Configuration.RecursiveDependencyException" />
            class with the <paramref name="typeChain">chain</paramref>
            of depedencies that caused the exception.
            </summary>
      <param name="typeChain">The sequence of types that caused the dependency exception.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.RecursiveDependencyException.TypeChain">
      <summary>
            Gets the value indicating the chain of types that caused the exception.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.RecursiveDependencyException.Message">
      <summary>
            Gets the value indicating the error message from the <see cref="T:LinFu.IoC.Configuration.RecursiveDependencyException" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ReflectionMethodBuilder`1">
      <summary>
            Represents a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1" /> type that simply lets 
            methods pass through it without performing any modifications to those methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ReflectionMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Returns the <paramref name="existingMethod" /> unmodified.
            </summary>
      <param name="existingMethod">The method to be modified.</param>
      <returns>The modified method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver">
      <summary>
            Represents a type that can generate method arguments
            from an existing <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IArgumentResolver.ResolveFrom(System.Collections.Generic.IEnumerable{LinFu.IoC.Configuration.Interfaces.INamedType},LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Generates constructor arguments from the given <paramref name="parameterTypes" />
            and <paramref name="container" />.
            </summary>
      <param name="parameterTypes">The parameter types for the target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects that represent the arguments to be passed to the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ArgumentResolver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.ResolveFrom(System.Collections.Generic.IEnumerable{LinFu.IoC.Configuration.Interfaces.INamedType},LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Generates method arguments from the given <paramref name="parameterTypes" />
            and <paramref name="container" />.
            </summary>
      <param name="parameterTypes">The parameter types for the target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects that represent the arguments to be passed to the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.AddArrayArgument(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.ICollection{System.Object})">
      <summary>
            Constructs an array of services using the services currently available
            in the <paramref name="container" />.
            </summary>
      <param name="parameterType">The current parameter type.</param>
      <param name="container">The container that will be used to build the array of services.</param>
      <param name="argumentList">The list that will store new service array.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.AddEnumerableArgument(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.ICollection{System.Object})">
      <summary>
            Determines whether or not a parameter type is an existing
            list of available services and automatically constructs the
            service list and adds it to the <paramref name="argumentList" />.
            </summary>
      <param name="parameterType">The current constructor parameter type.</param>
      <param name="container">The container that will provide the argument values.</param>
      <param name="argumentList">The list that will hold the arguments to be passed to the constructor.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1">
      <summary>
            Represents a class that can choose a member that best matches
            the services currently available in a given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TMember">The member type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1.ResolveFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Uses the <paramref name="container" /> to determine which member can be used to instantiate
            a <paramref name="concreteType">concrete type</paramref>.
            </summary>
      <param name="concreteType">The target type.</param>
      <param name="container">The container that contains the service instances that will be used to invoke the target member.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>A <typeparamref name="TMember" /> instance if a match is found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MemberResolver`1">
      <summary>
            Represents a class that can choose a member that best matches
            the services currently available in a given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TMember">The member type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.#ctor">
      <summary>
            The default constructor for the <see cref="T:LinFu.IoC.Configuration.MemberResolver`1" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinder{`0}})">
      <summary>
            Initializes the class with a <paramref name="getFinder">functor</paramref>
            that will be used to instantiate the method finder that will be used in the search.
            </summary>
      <param name="getFinder">The functor that will be used to instantiate the method finder.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.ResolveFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Uses the <paramref name="container" /> to determine which member to use from
            the <paramref name="concreteType">concrete type</paramref>.
            </summary>
      <param name="concreteType">The target type.</param>
      <param name="container">The container that contains the member values that will be used to invoke the members.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>A member instance if a match is found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetMethodFinder(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> that will be used
            in the method search.
            </summary>
      <param name="container">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetDefaultResult(System.Type)">
      <summary>
            The method used to retrieve the default result if no
            other alternative is found.
            </summary>
      <param name="concreteType">The target type that contains the default member.</param>
      <returns>The default member result.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetMembers(System.Type)">
      <summary>
            Lists the members associated with the <paramref name="concreteType" />.
            </summary>
      <param name="concreteType">The target type that contains the type members.</param>
      <returns>A list of members that belong to the concrete type.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorResolver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinder{System.Reflection.ConstructorInfo}})">
      <summary>
            Initializes the class using the custom method finder.
            </summary>
      <param name="getFinder">The functor that will be used to instantiate the method finder.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.GetMembers(System.Type)">
      <summary>
            Returns the constructors that belong to the <paramref name="concreteType" />.
            </summary>
      <param name="concreteType">The type that contains the list of constructors.</param>
      <returns>A list of constructors that belong to the <paramref name="concreteType" />.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.GetDefaultResult(System.Type)">
      <summary>
            Returns the parameterless constructor in case the search fails.
            </summary>
      <param name="concreteType">The target type that contains the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodFinder`1">
      <summary>
            Represents a class that determines which method best matches the
            services currently in the target container.
            </summary>
      <typeparam name="T">The method type to search.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.GetBestMatch(System.Collections.Generic.IEnumerable{`0},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Determines which method best matches the
            services currently in the target container.
            </summary>
      <param name="items">The list of methods to search.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>Returns the method with the most resolvable parameters from the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.SelectBestMatch(System.Collections.Generic.IEnumerable{LinFu.Finders.Interfaces.IFuzzyItem{`0}})">
      <summary>
            Determines which item among the <paramref name="candidates" /> is the best match.
            </summary>
      <param name="candidates">The list of possible matches.</param>
      <returns>The best match if found; otherwise, it should return <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.Rank(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Adds additional <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> to the fuzzy search list.
            </summary>
      <param name="methods">The list of methods to rank.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.CheckArguments(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Attempts to match the <paramref name="additionalArgumentTypes" /> against the <paramref name="fuzzyList">list of methods</paramref>.
            </summary>
      <param name="fuzzyList">The list of items currently being compared.</param>
      <param name="additionalArgumentTypes">The set of <see cref="T:System.Type" /> instances that describe each supplied argument type.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1">
      <summary>
            A <see cref="T:LinFu.IoC.Configuration.MethodFinder`1" /> type that uses a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance to find a method with the most resolvable parameters.
            </summary>
      <typeparam name="TMethod">The method type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the target with the host container.
            </summary>
      <param name="container">The host <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.CheckParameters(LinFu.Finders.Interfaces.IFuzzyItem{`0},LinFu.IoC.Interfaces.IServiceContainer,System.Int32)">
      <summary>
            Examines a <see cref="T:System.Reflection.ConstructorInfo" /> instance
            and determines if it can be instantiated with the services embedded in
            the target <paramref name="container" />.
            </summary>
      <param name="fuzzyItem">The <see cref="T:LinFu.Finders.FuzzyItem`1" /> that represents the constructor to be examined.</param>
      <param name="container">The container that contains the services that will be used to instantiate the target type.</param>
      <param name="maxIndex">Indicates the index that 
            marks the point where the user-supplied arguments begin.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Rank(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Adds additional <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> to the fuzzy search list.
            </summary>
      <param name="methods">The list of methods to rank.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Container">
      <summary>
            Gets the value indicating the service container that will be used in the
            method search.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceInstance">
      <summary>
            A type that represents a service instance returned by a container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInstance.ServiceInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> instance 
            that describes the service instance itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInstance.Object">
      <summary>
            Gets the value indicating the service instance itself.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ServiceInstance">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IServiceInstance" /> interface.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.TypeCounter">
      <summary>
            Counts the number of occurrences of a specific type.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Increment(System.Type)">
      <summary>
            Increments the count for the current <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.CountOf(System.Type)">
      <summary>
            Returns the number of occurrences of a specific <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
      <returns>The number of occurrences for the given type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Decrement(System.Type)">
      <summary>
            Decrements the count for the current <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Reset">
      <summary>
            Resets the counts back to zero.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.TypeCounter.AvailableTypes">
      <summary>
            Gets the value indicating the types that are
            currently being counted.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.ICreateInstance">
      <summary>
            Represents a type that can create service instances from a given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" />.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.ICreateInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Creates a service instance using the given <paramref name="factoryRequest" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.CreatorFromInstance">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> type that generates an object instance from an existing instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CreatorFromInstance.#ctor(System.Object)">
      <summary>
            Initializes the class with the target <paramref name="instance" />.
            </summary>
      <param name="instance">The instance that will be returned every time the <see cref="M:LinFu.IoC.CreatorFromInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)" /> method is called.</param>
    </member>
    <member name="M:LinFu.IoC.CreatorFromInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Returns the object instance that given when the <see cref="T:LinFu.IoC.CreatorFromInstance" /> class instance was initialized.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.DefaultCreator">
      <summary>
            Represents the default implementation for the <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /></summary>
    </member>
    <member name="M:LinFu.IoC.DefaultCreator.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Creates a service instance using the given <paramref name="factoryRequest" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IGetService">
      <summary>
            Represents a class that determines the behavior a <see cref="T:LinFu.IoC.ServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IGetService.GetService(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Causes the container to instantiate the service using the given
            <paramref name="serviceRequest">service request</paramref>. If the service type cannot be created, it will simply return null.
            </summary>
      <returns>A valid object reference if the service can be created; otherwise, it will return <c>null</c></returns>
    </member>
    <member name="T:LinFu.IoC.DefaultGetServiceBehavior">
      <summary>
            Represents the default implementation for the <see cref="T:LinFu.IoC.Interfaces.IGetService" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.#ctor(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.#ctor(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.ICreateInstance,LinFu.IoC.Interfaces.IPreProcessor,LinFu.IoC.Interfaces.IPostProcessor)">
      <summary>
            Initializes the class with the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The target service container.</param>
      <param name="creator">The <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> instance responsible for instantiating service types.</param>
      <param name="preProcessor">The <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> that will allow users to intercept a given service request.</param>
      <param name="postProcessor">The <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance that will handle the results of a given service request.</param>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.GetService(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Instantiates the service described by the <paramref name="serviceRequest" />.
            </summary>
      <param name="serviceRequest">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> that describes the service that needs to be instantiated.</param>
      <returns>A valid object reference if the service can be found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactory`1">
      <summary>
            A strongly-typed version of <see cref="T:LinFu.IoC.Interfaces.IFactory" />. Allows users
            to create their own service instances
            </summary>
      <typeparam name="T">The instance type that can be created by this factory.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.BaseFactory`1">
      <summary>
            A factory base class that combines both the IFactory and
            the IFactory&lt;T&gt; interfaces into a single class.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.BaseFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given container.
            </summary>
      <remarks>
        <see cref="T:LinFu.IoC.Interfaces.IFactory" /> developers can inherit from this class
            instead of having to write their own custom factories
            from scratch. This should cut down on some of the boilerplate
            code necessary to get a factory class up and running.
            </remarks>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.DelegateFactory">
      <summary>
            Represents a class that uses a <see cref="T:System.MulticastDelegate" />
            to instantiate a service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.DelegateFactory.#ctor(System.MulticastDelegate)">
      <summary>
            Initializes the class with the given <paramref name="targetDelegate" /></summary>
      <param name="targetDelegate">The delegate that will be used to instantiate the factory.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.DelegateFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the service type using the given delegate.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service that needs to be created.</param>
      <returns>The service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryAdapter`1">
      <summary>
            An adapter that converts strongly-typed IFactory&lt;T&gt; 
            instances into an equivalent IFactory instance.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
    </member>
    <member name="M:LinFu.IoC.FactoryAdapter`1.#ctor(System.Object)">
      <summary>
            Creates the factory adapter using the given
            IFactory&lt;T&gt; instance.
            </summary>
      <param name="factory">The factory instance that
            will be called every time the <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method
            is called. </param>
    </member>
    <member name="M:LinFu.IoC.FactoryAdapter`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Overridden. Uses the strongly-typed factory
            to create the service instance every time
            the <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method 
            is called.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.FactoryAdapter`1.Factory">
      <summary>
            The factory that will create the service instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Factories.FunctorFactory">
      <summary>
            A class that converts a delegate into an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,System.Object})">
      <summary>
            Initializes the class with the given <paramref name="factoryMethod" />.
            </summary>
      <param name="factoryMethod">The delegate that will be used to instantiate a type.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates an object reference using the given factory method.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference that represents the service type.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.FunctorFactory`1">
      <summary>
            A class that converts a delegate into an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,System.Object})">
      <summary>
            Initializes the class with the given <paramref name="factoryMethod" />.
            </summary>
      <param name="factoryMethod">The delegate that will be used to instantiate a type.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the class with the given <paramref name="factoryMethod" />.
            </summary>
      <param name="factoryMethod">The delegate that will be used to instantiate a type.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates an object reference using the given factory method.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference that represents the service type.</returns>
    </member>
    <member name="T:LinFu.IoC.InstanceFactory">
      <summary>
            A factory that uses an existing object reference
            instead of creating a new service.
            </summary>
    </member>
    <member name="M:LinFu.IoC.InstanceFactory.#ctor(System.Object)">
      <summary>
            Creates a factory using the existing <paramref name="instance" />.
            </summary>
      <param name="instance">The existing object reference that the factory will return.</param>
    </member>
    <member name="M:LinFu.IoC.InstanceFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            A method that returns the existing object reference associated with
            this factory. 
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.LazyFactory">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> class that instantiates a factory only on request.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory})">
      <summary>
            Instantiates the class with the factory functor method.
            </summary>
      <param name="getFactory">The functor that will be responsible for instantiating the actual factory.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the actual factory instance and uses it to instantiate the target service type.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service to be created.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.LazyFactory`1">
      <summary>
            Represents a factory that returns strongly-typed IFactory instances.
            </summary>
      <typeparam name="T">The service type to be created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory})">
      <summary>
            Initializes the factory with the given <paramref name="getFactory" /> functor.
            </summary>
      <param name="getFactory">The functor that will instantiate the actual factory instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the service type using the actual factory.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the service to be created.</param>
      <returns>
      </returns>
    </member>
    <member name="T:LinFu.IoC.Factories.OncePerRequestFactory`1">
      <summary>
            A factory that creates a unique service instance every time
            the <see cref="M:LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method is called.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerRequestFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>OncePerRequestFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new OncePerRequestFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            This method creates a new service instance every time
            it is invoked. 
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.OncePerThreadFactory`1">
      <summary>
            A factory that creates service instances that are unique
            from within the same thread as the factory itself.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerThreadFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>OncePerThreadFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new OncePerThreadFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerThreadFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates the service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" />
            instance. Every service instance created from this factory will
            only be created once per thread.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A a service instance as thread-wide singleton.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.SingletonFactory`1">
      <summary>
            A factory that creates Singletons. Each service that this factory creates will only be created once per concrete type.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.SingletonFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>SingletonFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new SingletonFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.SingletonFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            A method that creates a service instance as a singleton.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A service instance as a singleton.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryExtensions">
      <summary>
            Extends the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance with a few helper methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryExtensions.CreateInstance(LinFu.IoC.Interfaces.IFactory,System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Creates an object instance.
            </summary>
      <param name="factory">The target factory.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="container">The target service contaienr.</param>
      <param name="additionalArguments">The additional arguments that will be used to create the service instance.</param>
      <returns>A service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryRequest">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> interface.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.Container">
      <summary>
            Gets the value indicating the service container that made the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.ServiceName">
      <summary>
            Gets the value indicating the service name.
            </summary>
      <remarks>A null service name indicates that no service name was given during the request.</remarks>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.ServiceType">
      <summary>
            Gets the value indicating the requested service type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.Arguments">
      <summary>
            Gets the value indicating the additional arguments given in the factory request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactoryStorage">
      <summary>
            Represents a class that stores factory instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.AddFactory(LinFu.IoC.Interfaces.IServiceInfo,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryStorage.AvailableFactories">
      <summary>
            Gets a value indicating the list of <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> objects
            that describe each available factory in the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.BaseFactoryStorage">
      <summary>
            Represents the default base implementation of the <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.AddFactory(LinFu.IoC.Interfaces.IServiceInfo,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.BaseFactoryStorage.AvailableFactories">
      <summary>
            Gets a value indicating the list of <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> objects
            that describe each available factory in the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.FactoryStorage">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance that adds generics support to the <see cref="T:LinFu.IoC.BaseFactoryStorage" /> implementation.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            can be used to create the given service described by the <paramref name="serviceInfo" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the service to be created.</param>
      <returns>
        <c>True</c> if the service can be created; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that can instantiate the
            service described by the <paramref name="serviceInfo" /> object instance.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the service to be created.</param>
      <returns>A <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance if the service can be instantiated; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.GetDefaultFactory(System.String,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Gets the default factory for a particular service type if no other factory instance can be found.
            </summary>
      <param name="serviceName">The name of the service.</param>
      <param name="serviceType">The service type.</param>
      <param name="factory">The original factory instance that was supposed to be created in order to instantiate the service instance.</param>
      <returns>The actual factory instance that will be used to create the service instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.GetGenericFactory(LinFu.IoC.Interfaces.IServiceInfo,LinFu.IoC.Interfaces.IFactory,System.String,System.Type)">
      <summary>
            Gets the generic factory for a concrete service type.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the service to be created.</param>
      <param name="factory">The factory instance that will be used to create the service.</param>
      <param name="serviceName">The name of the service.</param>
      <param name="actualServiceType">The service type.</param>
      <returns>A factory instance that can create the generic type.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryStorageExtensions">
      <summary>
            An extension class that adds a few helper methods to the
            <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.AddFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a factory to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that will store the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.GetFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameters">The list of additional parameter values that this factory type will use to instantiate the service.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.GetFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.ContainsFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.BaseInterceptor">
      <summary>
            A class that provides the most basic functionality for an interceptor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.#ctor">
      <summary>
            The default constructor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.#ctor(LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo})">
      <summary>
            Initializes the class with the <paramref name="methodInvoke" /> instance.
            </summary>
      <param name="methodInvoke">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> instance that will invoke the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call using the given
            <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that will 
            contain all the necessary information associated with a 
            particular method call.</param>
      <returns>The return value of the target method. If the return type of the target
            method is <see cref="!:void" />, then the return value will be ignored.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="P:LinFu.IoC.Interceptors.BaseInterceptor.MethodInvoker">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> instance
            that will be used to invoke the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.LazyInterceptor`1">
      <summary>
            An interceptor class that instantiates a target type only when
            the methods for that target are invoked.
            </summary>
      <typeparam name="T">The type of object to intercept.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.#ctor(System.Func{`0})">
      <summary>
            Initializes the class with the <paramref name="getInstance" />
            factory method.
            </summary>
      <param name="getInstance">The functor that will be used to create the actual object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            A method that uses the given factory method to provide a target
            for the method currently being invoked.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the current invocation context.</param>
      <returns>The target itself.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts the method and initializes the target instance before the 
            actual object is invoked.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the execution context.</param>
      <returns>The return value of the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.AroundInvokeAdapter">
      <summary>
            Adapts a <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance into an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" />.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.#ctor(System.Func{System.Object},LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo},LinFu.AOP.Interfaces.IAroundInvoke)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Interceptors.AroundInvokeAdapter" /> class.
            </summary>
      <param name="getTarget">The functor responsible for obtaining the target instance.</param>
      <param name="methodInvoke">The method invoker.</param>
      <param name="aroundInvoke">The target <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Converts the call to <see cref="M:LinFu.AOP.Interfaces.IInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)" /> to an
            <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> method call.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InterceptorAttributeLoader">
      <summary>
            The class responsible for loading interceptors marked with the
            <see cref="T:LinFu.IoC.Interceptors.InterceptsAttribute" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.#ctor(LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Initializes the class with the given <paramref name="loaderHost" />.
            </summary>
      <param name="loaderHost">The <see cref="T:LinFu.Reflection.ILoader`1" /> instance that will be responsible for loading the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.Load(System.Type)">
      <summary>
            Loads an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> derived class into a particular <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            so that the current interceptor type can intercept calls made to services created from the given
            target container.
            </summary>
      <param name="input">The interceptor type.</param>
      <returns>By default, this will always return an empty set of container actions. The actual interceptor itself will be injected at the end of the postprocessor chain.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not a target type is an interceptor.
            </summary>
      <param name="inputType">The target type currently being tested.</param>
      <returns>Returns <c>true</c> if the <paramref name="inputType" /> is an interceptor; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.CreateProxyFrom(LinFu.IoC.Interfaces.IServiceRequestResult,System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,LinFu.AOP.Interfaces.IInterceptor})">
      <summary>
            Generates a proxy instance from an existing <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the proxy type that must be generated.</param>
      <param name="getInterceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> functor that will create the interceptor which will handle all calls made to the proxy instance.</param>
      <returns>A service proxy.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InterceptsAttribute">
      <summary>
            The attribute class used to indentify interceptor classes.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptsAttribute.#ctor(System.Type)">
      <summary>
            Initializes the class with the given <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target type that will be intercepted.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptsAttribute.#ctor(System.String,System.Type)">
      <summary>
            Initializes the class with the given <paramref name="targetType" /> and <paramref name="serviceName" />.
            </summary>
      <param name="serviceName">The name of service that will be intercepted.</param>
      <param name="targetType">The target type that will be intercepted.</param>
    </member>
    <member name="P:LinFu.IoC.Interceptors.InterceptsAttribute.ServiceName">
      <summary>
            Gets the value indicating the name of the service to intercept.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interceptors.InterceptsAttribute.TargetType">
      <summary>
            Gets the value indicating the target type that will be intercepted.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InvocationInfoInterceptor">
      <summary>
            An interceptor that intercepts <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instances
            and replaces the original target instance with a surrogate instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InvocationInfoInterceptor.#ctor(LinFu.AOP.Interfaces.IInvocationInfo,System.Func{System.Object},LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo})">
      <summary>
            Initializes the class with a functor that can provide the actual target instance.
            </summary>
      <param name="getActualTarget">The <see cref="T:System.Func`1" /> that will provide the target instance that will be used for the method invocation.</param>
      <param name="methodInvoke">The method invoker.</param>
      <param name="realInfo">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InvocationInfoInterceptor.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.ProxyContainerPlugin">
      <summary>
            A <see cref="T:LinFu.IoC.Configuration.Interfaces.IContainerPlugin" /> implementation that inserts
            <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> instances at the beginning of a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            loading sequence.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.#ctor(LinFu.IoC.Interceptors.ProxyInjector)">
      <summary>
            Initializes the class with the given <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> instance.
            </summary>
      <param name="injector">The postprocessor that will inject proxies in place of actual service requests.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects a <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> into the <paramref name="target">target container</paramref>.
            </summary>
      <param name="target">The service container that will hold the <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" />.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.ProxyInjector">
      <summary>
            Represents a class that automatically injects a proxy instance
            instead of an actual service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyInjector.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,System.Boolean},System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,System.Object})">
      <summary>
            Initializes the class with the <paramref name="filterPredicate" />
            and the <paramref name="createProxy" /> factory method.
            </summary>
      <param name="filterPredicate">The predicate that will determine which service requests will be proxied.</param>
      <param name="createProxy">The factory method that will generate the proxy instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyInjector.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            A method that injects service proxies in place of the actual <see cref="P:LinFu.IoC.Interfaces.IServiceRequestResult.ActualResult" />.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the service request.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.IContainerLoader">
      <summary>
            Represents a loader that reads a file and converts it
            into an equivalent set of a set of <see cref="T:System.Action`1" />
            instances that can be applied to a particular
            instance of an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> class.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.Redirector">
      <summary>
            An interceptor class that redirects calls to another interceptor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.Redirector.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IScope">
      <summary>
            Represents a class that keeps track of all the disposable objects 
            created within a service container and disposes them when 
            the scope itself has been disposed.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Reflection.LateBoundExtensions">
      <summary>
            A class that adds late binding support to any CLR object.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" />.
            </summary>
      <param name="instance">The target instance that will be used to invoke the method.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="arguments">The arguments that will be passed to the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,LinFu.IoC.Configuration.MethodFinderContext)">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" /> and <paramref name="context" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="context">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``1(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The type argument that will be passed to the target method</typeparam>.
            <param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``2(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``3(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <typeparam name="T3">The third type argument that will be passed to the target method.</typeparam><param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``4(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <typeparam name="T3">The third type argument that will be passed to the target method.</typeparam><typeparam name="T4">The fourth type argument that will be passed to the target method.</typeparam><param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,System.Type[],System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="typeArguments">The type arguments that will be passed to the target method.</param>
      <param name="arguments">The arguments that will be passed to the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="T:LinFu.IoC.Scope">
      <summary>
            Represents a class that keeps track of all the disposable objects 
            created within a service container and disposes them when 
            the scope itself has been disposed.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Scope.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Inserts the scope into the target <paramref name="source">container</paramref>.
            </summary>
      <param name="source">The container that will hold the scope instance.</param>
    </member>
    <member name="M:LinFu.IoC.Scope.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Monitors the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> for any services that are created and automatically disposes them
            once the <see cref="T:LinFu.IoC.Interfaces.IScope" /> is disposed.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> that describes the service being instantiated.</param>
    </member>
    <member name="M:LinFu.IoC.Scope.Dispose">
      <summary>
            Disposes the services that have been created while the scope has been active.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceContainer">
      <summary>
            Represents a service container with additional
            extension points for customizing service instances
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.#ctor">
      <summary>
            Initializes the container with the default services.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.#ctor(LinFu.IoC.Interfaces.IGetService,LinFu.IoC.Interfaces.IFactoryStorage)">
      <summary>
            Initializes the container with a custom <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> type.
            </summary>
      <param name="getServiceBehavior">The instance that will be responsible for generating service instances.</param>
      <param name="factoryStorage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance responsible for determining which factory instance will instantiate a given service request.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.AddFactory(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.AddFactory(System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The service type to associate with the factory</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be responsible for creating the service instance</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.Contains(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not the given <paramref name="serviceType" />
            can be instantiated by the container.
            </summary>
      <param name="serviceType">The type of service to instantiate.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.GetService(System.Type,System.Object[])">
      <summary>
            Overridden. Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <remarks>
            This overload of the <c>GetService</c> method has been overridden
            so that its results can be handled by the postprocessors.
            </remarks>
      <seealso cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a null value.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.GetService(System.String,System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.Contains(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a service can be created using
            the given <paramref name="serviceName">service name</paramref>
            and <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.FactoryStorage">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance
            that will be used to store each <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.SuppressErrors">
      <summary>
            Gets or sets a <see cref="T:System.Boolean">System.Boolean</see> value
            that determines whether or not the container should throw
            a <see cref="T:LinFu.IoC.ServiceNotFoundException" /> if a requested service
            cannot be found or created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.PostProcessors">
      <summary>
            The list of postprocessors that will handle every
            service request result.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.PreProcessors">
      <summary>
            The list of preprocessors that will handle
            every service request before each actual service is created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.AvailableServices">
      <summary>
            The list of services currently available inside the container.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceNotFoundException">
      <summary>
            The exception thrown when a service type is
            requested from a container and that named container
            is unable to find or create that particular service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceNotFoundException.#ctor(System.Type)">
      <summary>
            Initializes the service exception using the
            given <paramref name="serviceType" /> as
            the service that was not found.
            </summary>
      <param name="serviceType">The service type being requested.</param>
    </member>
    <member name="P:LinFu.IoC.ServiceNotFoundException.Message">
      <summary>
            The error message that this particular exception
            will display.
            </summary>
    </member>
    <member name="T:LinFu.IoC.NamedServiceNotFoundException">
      <summary>
            The exception thrown when a service name and a service type is
            requested from a named container and that named container
            is unable to find or create that particular service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.NamedServiceNotFoundException.#ctor(System.String,System.Type)">
      <summary>
            Initializes the service exception using the
            given <paramref name="serviceType" /> as
            the service that was not found.
            </summary>
      <param name="serviceType">The service type being requested.</param>
      <param name="serviceName">The name of the service being requested.</param>
    </member>
    <member name="P:LinFu.IoC.NamedServiceNotFoundException.Message">
      <summary>
            The error message that this particular exception
            will display.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceInfo">
      <summary>
            Represents the default implementation of the ServiceInfo class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.#ctor(System.String,System.Type)">
      <summary>
            Initializes the class with the given <paramref name="serviceName" />
            and <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service.</param>
      <param name="serviceType">The type of service that can be created.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.#ctor(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Initializes the class with the given <paramref name="serviceName" />
            and <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service.</param>
      <param name="serviceType">The type of service that can be created.</param>
      <param name="arguments">The parameter types required by the given service.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.ToString">
      <summary>
            Displays the name of the current service and the current service type.
            </summary>
      <returns>The name of the current service and the current service type.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.Equals(System.Object)">
      <summary>
            Determines if the other object is equal to the current <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> instance.
            </summary>
      <param name="obj">The other object that will be used in the comparison.</param>
      <returns>Returns <c>true</c> if both instances have the same service name, implement the same service type and have the same arguments; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ArgumentTypes">
      <summary>
            Gets a value indicating the list of arguments required by this particular service.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceRequest">
      <summary>
            Reprsents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceRequest.#ctor(System.String,System.Type,System.Object[],LinFu.IoC.Interfaces.IFactory,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.ServiceRequest" /> class.
            </summary>
      <param name="serviceName">The name of the requested service.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="proposedArguments">The proposed set of arguments that will be given to the factory.</param>
      <param name="proposedFactory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to handle the service request.</param>
      <param name="container">The host container.</param>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ProposedArguments">
      <summary>
            Gets the value indicating the original arguments that
            were given during the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ProposedFactory">
      <summary>
            Gets the value indicating the original <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ActualArguments">
      <summary>
            Gets or sets the value indicating the actual arguments that
            will be used for the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ActualFactory">
      <summary>
            Gets or sets the value indicating the actual <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceRequestResult">
      <summary>
            Represents the results returned when a service request
            is made against an <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.OriginalResult">
      <summary>
            The raw object reference created by the container itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ActualResult">
      <summary>
            The result that will be returned from the container
            instead of the <see cref="P:LinFu.IoC.ServiceRequestResult.OriginalResult" />. 
            
            If this property is null, then the original result will be used.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.AdditionalArguments">
      <summary>
            Gets or sets the value indicating the additional arguments that
            were used during the service request.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.MethodBodyEmitter">
      <summary>
            Provides the default implementation for the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the MethodBodyEmitter class.
            </summary>
      <param name="source">
      </param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.Emit(System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition)">
      <summary>
            Generates a method body for the <paramref name="targetMethod" />.
            </summary>
      <param name="originalMethod">The method currently being intercepted.</param>
      <param name="targetMethod">The target method that will contain the new method body.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.EmitGetInterceptorInstruction(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Emits the IL instructions to obtain an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance for the proxy type.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for emitting the method body.</param>
      <param name="proxyType">The proxy type.</param>
      <param name="getInterceptorMethod">The getter method for the interceptor.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.ImplementNotFound(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Causes the <see cref="T:Mono.Cecil.Cil.CilWorker" /> to make the method throw a
            <see cref="T:System.NotImplementedException" /> if the method cannot be found.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for emitting the method body.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.SaveRefArguments(Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.ParameterDefinition},Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the ref arguments of a given method using the
            <paramref name="arguments" /> from the <paramref name="invocationInfo" />
            object.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will emit the method body.</param>
      <param name="parameters">The parameters of the target method.</param>
      <param name="invocationInfo">The local variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="arguments">The local variable that will store the arguments from the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="P:LinFu.Proxy.MethodBodyEmitter.InvocationInfoEmitter">
      <summary>
            The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance that
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyBuilder">
      <summary>
            A <see cref="T:LinFu.Proxy.Interfaces.IProxyBuilder" /> type that generates
            proxies that forward all virtual method calls to a 
            single interceptor.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.#ctor">
      <summary>
            Initializes the current class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the current instance
            with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will hold the current instance.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that forwards all virtual method calls
            to a single <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
      <param name="originalBaseType">The base class of the type being constructed.</param>
      <param name="baseInterfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.ProxyImplementor">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.Emit.Interfaces.ITypeBuilder" /> interface
            which will emit the actual implementation of the IProxy interface.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.MethodPicker">
      <summary>
            Gets or sets the <see cref="T:LinFu.Proxy.Interfaces.IMethodPicker" />
            instance that will determine which methods
            will be proxied by the proxy builder.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.ProxyMethodBuilder">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IMethodBuilder" /> instance
            that will be responsible for generating each method
            for the current target type.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.InterfaceExtractor">
      <summary>
            Provides the default implementation for the 
            <see cref="T:LinFu.Proxy.Interfaces.IExtractInterfaces" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.InterfaceExtractor.GetInterfaces(System.Type,System.Collections.Generic.HashSet{System.Type})">
      <summary>
            Determines which interfaces a given type should implement.
            </summary>
      <param name="currentType">The base type that holds the list of interfaces to implement.</param>
      <param name="interfaceList">The list of interfaces already being implemented. </param>
    </member>
    <member name="T:LinFu.Proxy.MethodPicker">
      <summary>
            Represents the default class implementation for the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodPicker" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodPicker.ChooseProxyMethodsFrom(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which methods can be proxied from 
            the given <paramref name="baseType" /> and <paramref name="baseInterfaces" />. 
            </summary>
      <remarks>By default, only public virtual methods will be proxied.</remarks>
      <param name="baseType">The base class of the proxy type currently being generated.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy must implement.</param>
      <returns>A list of <see cref="T:System.Reflection.MethodInfo" /> objects that can be proxied.</returns>
    </member>
    <member name="T:LinFu.Proxy.ProxyCache">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.Proxy.Interfaces.IProxyCache" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Contains(System.Type,System.Type[])">
      <summary>
            Determines whether or not the cache contains an existing proxy type
            that is derived from the <paramref name="baseType" /> and implements
            the given <paramref name="baseInterfaces" />.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns <c>true</c> if the proxy type already exists; otherwise, it will return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Get(System.Type,System.Type[])">
      <summary>
            Retrieves an existing proxy type from the cache.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns a valid <see cref="T:System.Type" /> if the type already exists; otherwise, it might return <c>null</c> or opt to throw an exception.</returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Store(System.Type,System.Type,System.Type[])">
      <summary>
            Stores a proxy type in the cache.
            </summary>
      <param name="result">The proxy type to be stored.</param>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
    </member>
    <member name="T:LinFu.Proxy.ProxyCacheEntry">
      <summary>
            Represents a cached proxy type.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyFactory">
      <summary>
            Provides the basic implementation for a proxy factory class.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.#ctor">
      <summary>
            Initializes the proxy factory with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.Proxy.ProxyFactory" /> instance
            with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will hold the ProxyFactory.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.CreateProxyType(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a proxy type using the given
            <paramref name="baseType" /> as the base class
            and ensures that the proxy type implements the given
            interface types.
            </summary>
      <param name="baseType">The base class from which the proxy type will be derived.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy will implement.</param>
      <returns>A forwarding proxy.</returns>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.InterfaceExtractor">
      <summary>
            Gets or sets the <see cref="T:LinFu.Proxy.Interfaces.IExtractInterfaces" /> type that will be
            responsible for determining which interfaces
            the proxy type should implement.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.ProxyBuilder">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IProxyBuilder" /> instance that is
            responsible for generating the proxy type.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.Verifier">
      <summary>
            The <see cref="T:LinFu.AOP.Cecil.Interfaces.IVerifier" /> instance that will be used to 
            ensure that the generated assemblies are valid.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.Cache">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Proxy.Interfaces.IProxyCache" />
            instance that will be used to cache previous proxy generation runs.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyImplementor">
      <summary>
            A class that provides the default implementation
            for the IProxy interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyImplementor.Construct(Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Constructs a type that implements the
            <see cref="T:LinFu.Proxy.Interfaces.IProxy" /> interface.
            </summary>
      <param name="module">The module that will hold the target type.</param>
      <param name="targetType">The type that will implement the <see cref="T:LinFu.Proxy.Interfaces.IProxy" /> interface.</param>
    </member>
    <member name="T:LinFu.Proxy.ProxyMethodBuilder">
      <summary>
            Represents the default implementation of the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodBuilder" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.#ctor">
      <summary>
            Initializes the <see cref="T:LinFu.Proxy.ProxyMethodBuilder" /> class with the default property values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will create the class instance.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.CreateMethod(Mono.Cecil.TypeDefinition,System.Reflection.MethodInfo)">
      <summary>
            Creates a method that matches the signature defined in the
            <paramref name="method" /> parameter.
            </summary>
      <param name="targetType">The type that will host the new method.</param>
      <param name="method">The method from which the signature will be derived.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.MatchGenericArguments(Mono.Cecil.MethodDefinition,System.Collections.Generic.ICollection{System.Type})">
      <summary>
            Matches the generic parameters of <paramref name="newMethod">a target method</paramref></summary>
      <param name="newMethod">The generic method that contains the generic type arguments.</param>
      <param name="typeArguments">The array of <see cref="T:System.Type" /> objects that describe the generic parameters for the current method.</param>
    </member>
    <member name="P:LinFu.Proxy.ProxyMethodBuilder.Emitter">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter" /> instance that will be
            responsible for generating the method body.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyObjectReference">
      <summary>
            Represents a helper class that deserializes proxy instances.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the ProxyObjectReference class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class that contains the serialized data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.GetRealObject(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Returns the deserialized proxy instance.
            </summary>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes the proxy to a stream. 
            </summary>
      <remarks>This method override does nothing.</remarks>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class that contains the serialized data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
    </member>
    <member name="T:LinFu.Proxy.SerializableProxyBuilder">
      <summary>
            Represents a <see cref="T:LinFu.Proxy.ProxyBuilder" /> type that can create serializable proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.SerializableProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that forwards all virtual method calls
            to a single <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
      <param name="originalBaseType">The base class of the type being constructed.</param>
      <param name="baseInterfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="T:LinFu.Proxy.ObjectExtensions">
      <summary>
            A class that adds proxy support to the <see cref="T:System.Object" /> class
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ObjectExtensions.CreateDuck``1(System.Object,System.Type[])">
      <summary>
            Creates a duck type that redirects its calls to the
            given <paramref name="target" />.
            </summary>
      <param name="target">The target instance that will be invoked once the duck type instance has been invoked.</param>
      <param name="baseInterfaces">The additional list of interfaces that will be implemented by the duck type.</param>
      <typeparam name="T">The type parameter that describes the duck type.</typeparam>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.Proxy.ObjectExtensions.CreateDuck(System.Object,System.Type,System.Type[])">
      <summary>
            Creates a duck type that redirects its calls to the
            given <paramref name="target" />.
            </summary>
      <param name="target">The target instance that will be invoked once the duck type instance has been invoked.</param>
      <param name="duckType">The <see cref="T:System.Type" /> that describes the duck type.</param>
      <param name="baseInterfaces">The additional list of interfaces that will be implemented by the duck type.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.CallAdapter">
      <summary>
            Adapts an <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance to an
            <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.CallAdapter.#ctor(LinFu.AOP.Interfaces.IInvokeWrapper)">
      <summary>
            Initializes the CallAdapter class with the <paramref name="wrapper" /> instance.
            </summary>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be called every time the interceptor is invoked.</param>
    </member>
    <member name="M:LinFu.Proxy.CallAdapter.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call and passes the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> arguments
            down to the <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the method currently being executed.</param>
      <returns>The return value of the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.FunctorAsInterceptor">
      <summary>
            A class that converts a functor into an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.FunctorAsInterceptor.#ctor(System.Func{LinFu.AOP.Interfaces.IInvocationInfo,System.Object})">
      <summary>
            Initializes the class with the given <paramref name="intercept">functor</paramref>.
            </summary>
      <param name="intercept">The functor that will be invoked every time a method is called on the proxy type.</param>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.FunctorAsInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            A method that redirects the method calls to 
            the functor instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method call.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IExtractInterfaces">
      <summary>
            A class that is responsible for determining
            which interfaces a given type should implement.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IExtractInterfaces.GetInterfaces(System.Type,System.Collections.Generic.HashSet{System.Type})">
      <summary>
            Determines which interfaces a given type should implement.
            </summary>
      <param name="currentType">The base type that holds the list of interfaces to implement.</param>
      <param name="interfaces">The list of interfaces already being implemented. </param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter">
      <summary>
            Represents a class that is responsible for
            constructing method bodies.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodBodyEmitter.Emit(System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition)">
      <summary>
            Generates the method body for the <paramref name="targetMethod">target method</paramref>.
            </summary>
      <param name="originalMethod">The original method that the <paramref name="targetMethod" /> will be based on.</param>
      <param name="targetMethod">The method that will contain the method body to be emitted.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodPicker">
      <summary>
            Represents a class that determines which methods should be proxied
            by a given proxy factory.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodPicker.ChooseProxyMethodsFrom(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which methods should be proxied
            by a given proxy factory.
            </summary>
      <param name="baseType">The base class of the proxy type currently being generated.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy must implement.</param>
      <returns>A list of <see cref="T:System.Reflection.MethodInfo" /> objects that can be proxied.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodBuilder">
      <summary>
            Represents a class that generates methods based on other existing
            methods.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodBuilder.CreateMethod(Mono.Cecil.TypeDefinition,System.Reflection.MethodInfo)">
      <summary>
            Creates a method that matches the signature defined in the
            <paramref name="method" /> parameter.
            </summary>
      <param name="targetType">The type that will host the new method.</param>
      <param name="method">The method from which the signature will be derived.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyCache">
      <summary>
            Represents an interface for classes that store results from an
            <see cref="T:LinFu.Proxy.Interfaces.IProxyFactory" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Contains(System.Type,System.Type[])">
      <summary>
            Determines whether or not the cache contains an existing proxy type
            that is derived from the <paramref name="baseType" /> and implements
            the given <paramref name="baseInterfaces" />.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns <c>true</c> if the proxy type already exists; otherwise, it will return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Get(System.Type,System.Type[])">
      <summary>
            Retrieves an existing proxy type from the cache.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns a valid <see cref="T:System.Type" /> if the type already exists; otherwise, it might return <c>null</c> or opt to throw an exception.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Store(System.Type,System.Type,System.Type[])">
      <summary>
            Stores a proxy type in the cache.
            </summary>
      <param name="result">The proxy type to be stored.</param>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxy">
      <summary>
            Represents a dynamically generated proxy instance.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.Interfaces.IProxy.Interceptor">
      <summary>
            The interceptor that will handle all
            calls made to the proxy instance.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyBuilder">
      <summary>
            Represents a class that is responsible
            for generating proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that must be derived
            from the <paramref name="baseType" /> and implement
            the list of <paramref name="interfaces" />.
            </summary>
      <param name="baseType">The base class of the type being constructed.</param>
      <param name="interfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyFactory">
      <summary>
            Represents the basic interface for creating
            dynamic proxy instances.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyFactory.CreateProxyType(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Generates a dynamic proxy type
            that derives from the <paramref name="baseType" />
            and implements the given <paramref name="baseInterfaces">interfaces</paramref>.
            </summary>
      <param name="baseType">The base class from which the generated dynamic proxy will be derived.</param>
      <param name="baseInterfaces">The list of interfaces that the generated dynamic proxy will implement.</param>
      <returns>A dynamic proxy type.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.ProxyFactoryExtensions">
      <summary>
            Extends the <see cref="T:LinFu.Proxy.Interfaces.IProxyFactory" /> class to support
            instantiating proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,LinFu.AOP.Interfaces.IInvokeWrapper,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <paramref name="instanceType" /> 
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="wrapper" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="instanceType">The type that will be intercepted by the proxy.</param>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,LinFu.AOP.Interfaces.IInterceptor,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <paramref name="instanceType" /> 
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="interceptor" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="instanceType">The type that will be intercepted by the proxy.</param>
      <param name="interceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,LinFu.AOP.Interfaces.IInvokeWrapper,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="wrapper" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,LinFu.AOP.Interfaces.IInterceptor,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="interceptor" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="interceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,System.Func{System.String,System.Type[],System.Object[],System.Object},System.Type[])">
      <summary>
            Uses the <paramref name="proxyFactory" /> to create a proxy instance
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            </summary>
      <remarks>
            The <paramref name="proxyImplementation" /> will be used to intercept method calls
            performed against the target instance.
            </remarks>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="proxyFactory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="proxyImplementation">The functor that will invoked every time a method is called on the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,System.Func{System.String,System.Type[],System.Object[],System.Object},System.Type[])">
      <summary>
            Uses the <paramref name="proxyFactory" /> to create a proxy instance
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            </summary>
      <remarks>
            The <paramref name="proxyImplementation" /> will be used to intercept method calls
            performed against the target instance.
            </remarks>
      <param name="targetType">The type that will be intercepted by the proxy.</param>
      <param name="proxyFactory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="proxyImplementation">The functor that will invoked every time a method is called on the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.ITypeExtractor`2">
      <summary>
            Represents a type that can extract <see cref="T:System.Type" />
            objects from an <see cref="T:System.Reflection.Assembly" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.ITypeExtractor`2.GetTypes(`0)">
      <summary>
            Returns a set of types from a given assembly.
            </summary>
      <param name="targetAssembly">The <see cref="T:System.Reflection.Assembly" /> that contains the target types.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of types from the target assembly.</returns>
    </member>
    <member name="T:LinFu.Reflection.ITypeExtractor">
      <summary>
            Represents a type that can extract <see cref="T:System.Type" />
            objects from an <see cref="T:System.Reflection.Assembly" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.IInitialize`1">
      <summary>
            Represents classes that need to be initialized
            every time a particular 
            instance creates that type.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.IInitialize`1.Initialize(`0)">
      <summary>
            Initializes the target with the
            particular <typeparamref name="T" /> instance.
            </summary>
      <param name="source">The <typeparamref name="T" /> instance that will hold the target type.</param>
    </member>
    <member name="T:LinFu.Reflection.IActionLoader`2">
      <summary>
            Represents a class that can configure 
            a target of type <typeparamref name="TTarget" />
            using an input type of <typeparamref name="TInput" />.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
      <typeparam name="TInput">The input that will be used to configure the target.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.IActionLoader`2.Load(`1)">
      <summary>
            Generates a set of <see cref="T:System.Action`1" /> instances
            using the given <paramref name="input" />.
            </summary>
      <param name="input">The input that will be used to configure the target.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.IActionLoader`2.CanLoad(`1)">
      <summary>
            Determines if the PluginLoader can load the <paramref name="inputType" />.
            </summary>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.ILoaderPlugin`1">
      <summary>
            Represents a component that can monitor
            a target instance as it loads.
            </summary>
      <typeparam name="TTarget">The target instance type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.ILoaderPlugin`1.BeginLoad(`0)">
      <summary>
            Signals the beginning of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoaderPlugin`1.EndLoad(`0)">
      <summary>
            Signals the end of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.Plugins.BaseLoaderPlugin`1">
      <summary>
            A class that implements the basic functionality of
            a loader plugin.
            </summary>
      <typeparam name="TTarget">The type being loaded.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseLoaderPlugin`1.BeginLoad(`0)">
      <summary>
            Signals the beginning of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseLoaderPlugin`1.EndLoad(`0)">
      <summary>
            Signals the end of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3">
      <summary>
            A plugin class that provides the basic implementation
            for plugins that work with <see cref="T:LinFu.Reflection.IAssemblyTargetLoader`1" /> instances.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
      <typeparam name="TAssembly">The assembly type.</typeparam>
      <typeparam name="TType">The input type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3.#ctor(LinFu.Reflection.ITypeExtractor{`1,`2},LinFu.Reflection.IAssemblyTargetLoader{`0,`1,`2})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3" /> class.
            </summary>
      <param name="typeExtractor">The type extractor that will pull the types out of the current assembly.</param>
      <param name="assemblyLoader">The assembly loader that will load the current assembly into memory.</param>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3.Initialize(LinFu.Reflection.ILoader{`0})">
      <summary>
            Searches the loader for an <see cref="T:LinFu.Reflection.IAssemblyTargetLoader`1" />
            instance and uses its derived classes to initialize
            the assembly target loader.
            </summary>
      <param name="source">The <see cref="T:LinFu.Reflection.ILoader`1" /> instance that will hold the plugin.</param>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3.Initialize(LinFu.Reflection.ILoader{`0},LinFu.Reflection.IAssemblyTargetLoader{`0,`1,`2})">
      <summary>
            Initializes the <paramref name="loader" /> instance
            with the given <paramref name="assemblyLoader" /> instance.
            </summary>
      <param name="loader">The loader being configured.</param>
      <param name="assemblyLoader">The assembly loader that will load the types into the loader itself.</param>
    </member>
    <member name="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1">
      <summary>
            A plugin class that provides the basic implementation
            for plugins that work with <see cref="T:LinFu.Reflection.IAssemblyTargetLoader`1" /> instances.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3" /> class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1.#ctor(LinFu.Reflection.ITypeExtractor{System.Reflection.Assembly,System.Type})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`3" /> class.
            </summary>
      <param name="typeExtractor">The type extractor that will pull the types out of the current assembly.</param>
    </member>
    <member name="T:LinFu.Reflection.ILoader`1">
      <summary>
            Represents a generic interface for an abstract loader
            that can read configuration information from disk
            and apply it to a <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The class type being configured.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.LoadDirectory(System.String,System.String)">
      <summary>
            Loads the configuration using the files listed in 
            the target <paramref name="directory" /> that match 
            the given <paramref name="filespec">file pattern</paramref>.
            </summary>
      <param name="directory">The full path of the location to scan.</param>
      <param name="filespec">The wildcard file pattern string to use when specifying the target files.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.LoadInto(`0)">
      <summary>
            Configures the <paramref name="target" /> instance 
            using the configuration currently loaded from disk.
            </summary>
      <param name="target">The <typeparamref name="TTarget" /> instance to be configured.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.Reset">
      <summary>
            Clears the currently loaded configuration
            and resets the loader back to its defaults.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.Plugins">
      <summary>
            The list of <see cref="T:LinFu.Reflection.ILoaderPlugin`1" />
            instances that will be used to
            signal the beginning and end of the
            load sequence.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.FileLoaders">
      <summary>
            The list of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances responsible for configuring the <typeparamref name="TTarget" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.DirectoryLister">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.IDirectoryListing" /> instance 
            responsible for returning a list of filenames
            to the loader for processing.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.CustomLoaderActions">
      <summary>
            The custom list of actions that will be
            performed prior to the beginning of a load operation.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.QueuedActions">
      <summary>
            The list of actions that will execute
            every time a target instance is configured.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.Loader`3">
      <summary>
            Represents a generic loader class that can
            load multiple <see cref="T:System.Action`1" /> delegates from multiple files and
            apply them to a particular <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
      <typeparam name="TAssembly">The assembly type.</typeparam>
      <typeparam name="TType">The target type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.#ctor(LinFu.Reflection.ITypeExtractor{`1,`2},LinFu.Reflection.IAssemblyLoader{`1})">
      <summary>
            Initializes the target with the default settings.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.#ctor(LinFu.Reflection.ITypeExtractor{`1,`2},LinFu.Reflection.IAssemblyLoader{`1},LinFu.Reflection.IActionLoader{LinFu.Reflection.ILoader{`0},`2})">
      <summary>
            Initializes the target with the default settings.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.LoadDirectory(System.String,System.String)">
      <summary>
            Loads the container with the files listed in 
            the target <paramref name="directory" /> that match 
            the given <paramref name="filespec">file pattern</paramref>.
            </summary>
      <param name="directory">The full path of the location to scan.</param>
      <param name="filespec">The wildcard file pattern string to use when specifying the target files.</param>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.LoadInto(`0)">
      <summary>
            Loads the current configuration into the <paramref name="target" />
            instance.
            </summary>
      <param name="target">
      </param>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.Reset">
      <summary>
            Clears the currently loaded configuration
            and resets the loader back to its defaults.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.AutoLoadFrom(System.String,System.String,`0)">
      <summary>
            Monitors the given <paramref name="directory" /> for any file changes and
            updates the current loader whenever the files that match the given <paramref name="fileSpec" />
            are loaded into memory
            </summary>
      <param name="directory">The full path of the location to scan.</param>
      <param name="fileSpec">The wildcard file pattern string to use when specifying the target files.</param>
      <param name="target">The target that will be loaded using the current loader.</param>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.ShouldLoad(LinFu.Reflection.ILoaderPlugin{`0})">
      <summary>
            Determines whether or not a specific plugin should be loaded.
            </summary>
      <param name="plugin">The target plugin to be loaded.</param>
      <returns>
        <c>true</c> if the plugin should be loaded; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.Loader`3.LoadFile(System.String)">
      <summary>
            Loads the <paramref name="currentFile">current file</paramref>
            using the list of associated <see cref="P:LinFu.Reflection.Loader`3.FileLoaders" />.
            </summary>
      <param name="currentFile">The full path and filename being loaded.</param>
    </member>
    <member name="P:LinFu.Reflection.Loader`3.QueuedActions">
      <summary>
            The list of actions that will execute
            every time a target instance is configured.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`3.CustomLoaderActions">
      <summary>
            The custom list of actions that will be
            performed prior to the beginning of the first load operation.
            </summary>
      <remarks>
            These actions will be performed only once per reset.
            </remarks>
    </member>
    <member name="P:LinFu.Reflection.Loader`3.Plugins">
      <summary>
            The list of <see cref="T:LinFu.Reflection.ILoaderPlugin`1" />
            instances that will be used to
            signal the beginning and end of the
            load sequence.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`3.FileLoaders">
      <summary>
            The list of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances responsible for configuring the target instance.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`3.DirectoryLister">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.IDirectoryListing" /> instance 
            responsible for returning a list of filenames
            to the loader for processing.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.Loader`1">
      <summary>
            Represents a generic loader class that can
            load multiple <see cref="T:System.Action`1" /> delegates from multiple files and
            apply them to a particular <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">
      </typeparam>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.#ctor">
      <summary>
            Initializes the target with the default settings.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.Runtime">
      <summary>
            Adds helper methods that return information about the current
            runtime.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Runtime.IsRunningOnMono">
      <summary>
            Gets a value indicating if the application is
            currently running on the Mono platform.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.BasePluginLoader`2">
      <summary>
            Implements the basic functionality of a plugin loader.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
      <typeparam name="TAttribute">The attribute type that will be used to mark a type as a plugin.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.BasePluginLoader`2.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.BasePluginLoader`2.Load(System.Type)">
      <summary>
            Generates a set of <see cref="T:System.Action`1" /> instances
            using the given <paramref name="input" />.
            </summary>
      <param name="input">The input that will be used to configure the target.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.CollectionLoader`1">
      <summary>
            Represents an action loader that can load collections from types embedded within a given assembly.
            </summary>
      <typeparam name="T">The collection item type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.CollectionLoader`1.Load(System.Type)">
      <summary>
            Creates the list of actions that load the target collection into memory.
            </summary>
      <param name="input">The source type.</param>
      <returns>A list of actions that load the target collection into memory.</returns>
    </member>
    <member name="M:LinFu.Reflection.CollectionLoader`1.CanLoad(System.Type)">
      <summary>
            Determines whether or not the given type can be loaded into memory.
            </summary>
      <param name="inputType">The source type.</param>
      <returns>Returns <c>true</c> if the type can be loaded into memory; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyTargetLoader`3">
      <summary>
            Represents a specific <see cref="T:LinFu.Reflection.IActionLoader`2" />
            type that can load configuration information from an assembly
            and apply it to a <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
      <typeparam name="TAssembly">The assembly type.</typeparam>
      <typeparam name="TType">The input type.</typeparam>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`3.AssemblyLoader">
      <summary>
            The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will load
            the target assemblies.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`3.TypeLoaders">
      <summary>
            The list of ActionLoaders that will be used to
            configure the target.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyTargetLoader`3">
      <summary>
            Represents a loader class that takes <see cref="T:System.Type" />
            instances as input and generates <see cref="T:System.Action`1" />
            instances that can be used to configure a <typeparamref name="TTarget" />
            instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
      <typeparam name="TAssembly">The assembly type.</typeparam>
      <typeparam name="TType">The target type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`3.#ctor(LinFu.Reflection.ITypeExtractor{`1,`2},LinFu.Reflection.IAssemblyLoader{`1})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.Reflection.AssemblyTargetLoader`3" /> class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`3.CanLoad(System.String)">
      <summary>
            Determines whether or not the current type loader
            instance can load the current file type.
            </summary>
      <remarks>
            This class only loads assemblies with the ".dll" extension.
            </remarks>
      <param name="filename">The filename and full path of the target file.</param>
      <returns>Returns <c>true</c> if the file can be loaded; otherwise, the result is <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`3.Load(System.String)">
      <summary>
            Reads an input file using the given <paramref name="filename" />
            and converts it into a set of <see cref="T:System.Action`1" />
            instances that can be applied to a target class instance..
            </summary>
      <remarks>This class can only load valid .NET Assemblies.</remarks>
      <param name="filename">The target file to be loaded.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances to apply to a target type.</returns>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`3.AssemblyActionLoader">
      <summary>
            Gets or sets the value indicating the action loader 
            responsible for reading an assembly and converts it to 
            a list of actions to be performed against the target type.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`3.AssemblyLoader">
      <summary>
            The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will load
            the target assemblies.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`3.TypeLoaders">
      <summary>
            The list of ActionLoaders that will be used to
            configure the target.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyTargetLoader`1">
      <summary>
            Represents a loader class that takes <see cref="T:System.Type" />
            instances as input and generates <see cref="T:System.Action`1" />
            instances that can be used to configure a <typeparamref name="TTarget" />
            instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`1.#ctor">
      <summary>
            Initializes the class with the default property values.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyActionLoader`3">
      <summary>
            A class that reads an assembly and converts it into a set of actions
            that can be used to build the list of actions against the <typeparamref name="TTarget" />
            type.
            </summary>
      <typeparam name="TTarget">The target type.</typeparam>
      <typeparam name="TAssembly">The assembly type.</typeparam>
      <typeparam name="TType">The target input type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`3.#ctor(System.Func{System.Collections.Generic.IList{LinFu.Reflection.IActionLoader{`0,`2}}},LinFu.Reflection.ITypeExtractor{`1,`2})">
      <summary>
            Initializes the class with a set of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances that will be used to load the target assembly.
            </summary>
      <param name="getTypeLoaders">The delegate that will return the actual list of typeloaders.</param>
      <param name="typeExtractor">The type extractor that will be responsible for pulling the types out of the current assembly.</param>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`3.Load(`1)">
      <summary>
            Loads the target assembly and creates an action that can
            create the list of actions which will modify the <typeparamref name="TTarget" /> instance.
            </summary>
      <param name="input">The target assembly.</param>
      <returns>The list of actions which will modify the list of actions that will be executed against the <typeparamref name="TTarget" /> instance.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`3.CanLoad(`1)">
      <summary>
            Determines if an assembly can be loaded.
            </summary>
      <param name="assembly">The target assembly.</param>
      <returns>Returns <c>true</c> if the assembly is not <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`3.CreateActionsFrom(`1,System.Collections.Generic.ICollection{System.Action{`0}})">
      <summary>
            Generates a list of actions from a target assemby.
            </summary>
      <param name="assembly">The target assembly.</param>
      <param name="resultList">The list that will store the resulting actions.</param>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`3.LoadResultsFromType(`2,System.Collections.Generic.ICollection{System.Action{`0}})">
      <summary>
            Generates the list of <see cref="T:System.Action`1" />
            instances which will be used to configure a target instance.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> instance that holds the configuration information.</param>
      <param name="results">The list that will hold the actions which will configure the container.</param>
    </member>
    <member name="P:LinFu.Reflection.AssemblyActionLoader`3.TypeExtractor">
      <summary>
            The <see cref="T:LinFu.Reflection.ITypeExtractor" /> instance that will
            determine which types will be extracted from an assembly.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyActionLoader`1">
      <summary>
            A class that reads an assembly and converts it into a set of actions
            that can be used to build the list of actions against the <typeparamref name="TTarget" />
            type.
            </summary>
      <typeparam name="TTarget">The target type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.#ctor(System.Func{System.Collections.Generic.IList{LinFu.Reflection.IActionLoader{`0,System.Type}}})">
      <summary>
            Initializes the class with a set of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances that will be used to load the target assembly.
            </summary>
      <param name="getTypeLoaders">The delegate that will return the actual list of typeloaders.</param>
    </member>
    <member name="T:LinFu.Reflection.LoaderPluginAttribute">
      <summary>
            Marks a class as a loader plugin type.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.TypeExtractor">
      <summary>
            Represents a type that can extract <see cref="T:System.Type" />
            objects from an <see cref="T:System.Reflection.Assembly" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.TypeExtractor.GetTypes(System.Reflection.Assembly)">
      <summary>
            Returns a set of types from a given assembly.
            </summary>
      <param name="targetAssembly">The <see cref="T:System.Reflection.Assembly" /> that contains the target types.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of types from the target assembly.</returns>
    </member>
    <member name="T:LinFu.Reflection.IDirectoryListing">
      <summary>
            Represents a class that can list the files
            in a given directory.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.IDirectoryListing.GetFiles(System.String,System.String)">
      <summary>
            Returns the names of the files in the specified directory
            that match the specified search pattern.
            </summary>
      <param name="path">The directory to search.</param>
      <param name="searchPattern">The search string to match against the names of the files in the <paramref name="path" />.</param>
      <returns>The list of files that match the <paramref name="path" /> and <paramref name="searchPattern" /></returns>
    </member>
    <member name="T:LinFu.Reflection.DefaultDirectoryLister">
      <summary>
            A class that lists the contents of a given directory.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.DefaultDirectoryLister.GetFiles(System.String,System.String)">
      <summary>
            Returns a list of files that match the <paramref name="searchPattern" />
            from the given directory <paramref name="path" />.
            </summary>
      <param name="path">The target directory to search.</param>
      <param name="searchPattern">The search string to match against the names of the files in the <paramref name="path" />.</param>
      <returns>The list of files that match the <paramref name="path" /> and <paramref name="searchPattern" /></returns>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyTargetLoader`1">
      <summary>
            Represents a specific <see cref="T:LinFu.Reflection.IActionLoader`2" />
            type that can load configuration information from an assembly
            and apply it to a <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`1.AssemblyLoader">
      <summary>
            The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will load
            the target assemblies.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`1.TypeLoaders">
      <summary>
            The list of ActionLoaders that will be used to
            configure the target.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyLoader`1">
      <summary>
            Represents a class that loads assemblies into memory
            from disk.
            </summary>
      <typeparam name="TAssembly">
      </typeparam>
    </member>
    <member name="M:LinFu.Reflection.IAssemblyLoader`1.Load(System.String)">
      <summary>
            Loads the target assembly into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyLoader">
      <summary>
            Represents a class that loads assemblies into memory
            from disk.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyLoader">
      <summary>
            Represents a class that loads assemblies into memory
            from disk.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.AssemblyLoader.Load(System.String)">
      <summary>
            Loads the target assembly into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.PluginLoader`2">
      <summary>
            Represents a loader class that can load
            <see cref="T:LinFu.Reflection.ILoaderPlugin`1" /> instances
            marked with a particular <typeparamref name="TAttribute" />
            type.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
      <typeparam name="TAttribute">The attribute type that marks a type as a plugin type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.PluginLoader`2.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement <see cref="T:LinFu.Reflection.ILoaderPlugin`1" /> before it can be loaded.</remarks>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.PluginLoader`2.Load(System.Type)">
      <summary>
            Loads a set of actions from a <see cref="T:System.Type" />
            instance.
            </summary>
      <param name="input">The target type to scan.</param>
      <returns>A set of actions which will be applied to the target <see cref="T:LinFu.Reflection.ILoader`1" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.CollectionExtensions">
      <summary>
            Adds additional support methods to the standard System.Collection classes.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.CollectionExtensions.HasElementWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines whether or not an element exists that matches the given
            <paramref name="predicate" />.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="items">The list of items being searched.</param>
      <param name="predicate">The predicate that will be used to describe the matching items.</param>
      <returns>Returns <c>true</c> if at least one match is found; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.CollectionExtensions.LoadFrom``1(System.Collections.Generic.ICollection{``0},System.String,System.String)">
      <summary>
            Loads a list of types that match the given <typeparamref name="T">target type</typeparamref>.
            </summary>
      <typeparam name="T">The target type to be loaded.</typeparam>
      <param name="list">The list that will hold the instances of the target type.</param>
      <param name="targetDirectory">The directory that will be used to scan for assemblies that contain the target type.</param>
      <param name="filespec">The wildcard pattern that describes the files to be loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.Emit.AssemblyDefinitionExtensions">
      <summary>
            A class that adds extension methods to the <see cref="T:Mono.Cecil.AssemblyDefinition" />
            class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.ToAssembly(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Converts an <see cref="T:Mono.Cecil.AssemblyDefinition" />
            into a running <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="definition">The <see cref="T:Mono.Cecil.AssemblyDefinition" /> to convert.</param>
      <returns>An <see cref="T:System.Reflection.Assembly" /> that represents the <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.Save(Mono.Cecil.AssemblyDefinition,System.String)">
      <summary>
            Saves the assembly to disk.
            </summary>
      <param name="definition">The target assembly definition.</param>
      <param name="filename">The output file name.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.Save(Mono.Cecil.AssemblyDefinition,System.IO.Stream)">
      <summary>
            Saves the assembly to disk.
            </summary>
      <param name="definition">The target assembly definition.</param>
      <param name="outputStream">The destination file stream.</param>
    </member>
    <member name="T:LinFu.Reflection.Emit.CilWorkerExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.Cil.CilWorker" /> class
            with helper methods that make it easier to save
            information about the method currently being implemented.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.EmitWriteLineIfNull(Mono.Cecil.Cil.CilWorker,System.String,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits a Console.WriteLine call to using the current CilWorker that will only be called if the contents
            of the target variable are null at runtime.
            </summary>
      <param name="IL">The target CilWorker.</param>
      <param name="text">The text that will be written to the console.</param>
      <param name="targetVariable">The target variable that will be checked for null at runtime.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.EmitWriteLine(Mono.Cecil.Cil.CilWorker,System.String)">
      <summary>
            Emits a Console.WriteLine call using the current CilWorker.
            </summary>
      <param name="IL">The target CilWorker.</param>
      <param name="text">The text that will be written to the console.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushMethod(Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the current <paramref name="method" /> onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The method that represents the <see cref="T:System.Reflection.MethodInfo" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetDeclaringType(Mono.Cecil.MethodReference)">
      <summary>
            Gets the declaring type for the target method.
            </summary>
      <param name="method">The target method.</param>
      <returns>The declaring type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushType(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes a <paramref name="Type" /> instance onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="type">The type that represents the <see cref="T:System.Type" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushField(Mono.Cecil.Cil.CilWorker,Mono.Cecil.FieldReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the current <paramref name="field" /> onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="field">The field that represents the <see cref="T:System.Reflection.FieldInfo" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the target field.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushArguments(Mono.Cecil.Cil.CilWorker,Mono.Cecil.IMethodSignature,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Pushes the arguments of a method onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="method">The target method.</param>
      <param name="arguments">The <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see> that will hold the array of arguments.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushStackTrace(Mono.Cecil.Cil.CilWorker,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the stack trace of the currently executing method onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushGenericArguments(Mono.Cecil.Cil.CilWorker,Mono.Cecil.IGenericParameterProvider,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the generic type arguments that were used to construct the method.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The target method whose generic type arguments (if any) will be saved into the <paramref name="typeArguments">local variable</paramref>.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="typeArguments">The local variable that will store the resulting array of <see cref="T:System.Type" /> objects.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.SaveParameterTypes(Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the current method signature of a method into an array
            of <see cref="T:System.Type" /> objects. This can be used to determine the
            signature of methods with generic type parameters or methods that have
            parameters that are generic parameters specified by the type itself.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The target method whose generic type arguments (if any) will be saved into the local variable .</param>
      <param name="module">The module that contains the host method.</param>
      <param name="parameterTypes">The local variable that will store the current method signature.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PackageReturnValue(Mono.Cecil.Cil.CilWorker,Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeReference)">
      <summary>
            Converts the return value of a method into the <paramref name="returnType">target type</paramref>.
            If the target type is void, then the value will simply be popped from the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="returnType">The method return type itself.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.Stind(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference)">
      <summary>
            Emits the proper Stind (store indirect) IL instruction for the <paramref name="currentType" />.
            </summary>
      <param name="IL">The target <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will emit the IL.</param>
      <param name="currentType">The type of data being stored.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushParameter(Mono.Cecil.Cil.CilWorker,System.Int32,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.ParameterDefinition)">
      <summary>
            Stores the <paramref name="param">current parameter value</paramref>
            into the array of method <paramref name="arguments" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="arguments">The local variable that will store the method arguments.</param>
      <param name="index">The array index that indicates where the parameter value will be stored in the array of arguments.</param>
      <param name="param">The current argument value being stored.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetMethod(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Obtains the method definition that contains the current <see cref="T:Mono.Cecil.Cil.CilWorker" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the method body.</param>
      <returns>A method definition.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetModule(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Obtains the module that contains the current <see cref="T:Mono.Cecil.Cil.CilWorker" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the method body.</param>
      <returns>The host module.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetDeclaringType(Mono.Cecil.TypeReference)">
      <summary>
            Obtains the declaring type for a given type reference.
            </summary>
      <param name="declaringType">The declaring ty pe.</param>
      <returns>The actual declaring type.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.Interfaces.ITypeBuilder">
      <summary>
            Represents a type that can construct <see cref="T:Mono.Cecil.TypeDefinition" />
            types.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.Interfaces.ITypeBuilder.Construct(Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Constructs a <paramref name="targetType" /> using
            the given <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">The module that will hold the actual type.</param>
      <param name="targetType">The type being constructed.</param>
    </member>
    <member name="T:LinFu.Reflection.Emit.MethodDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.MethodDefinition" />
            class with features similar to the features in the
            System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.GetILGenerator(Mono.Cecil.MethodDefinition)">
      <summary>
            Returns the <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance
            associated with the body of the <paramref name="method">target method</paramref>.
            </summary>
      <param name="method">The target method to be modified.</param>
      <returns>The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that points to the instructions of the method body.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <param name="localType">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.String,System.Type)">
      <summary>
            Adds a named <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="method">method definition</paramref>.
            </summary>
      <param name="method">The <paramref name="method" /> instance which will contain the local variable.</param>
      <param name="variableName">The name of the local variable.</param>
      <param name="variableType">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddParameters(Mono.Cecil.MethodDefinition,System.Type[])">
      <summary>
            Adds a set of parameter types to the target <paramref name="method" />.
            </summary>
      <param name="method">The target method.</param>
      <param name="parameterTypes">The list of types that describe the method signature.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.SetReturnType(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Assigns the <paramref name="returnType" /> for the target method.
            </summary>
      <param name="method">The target method.</param>
      <param name="returnType">The <see cref="T:System.Type" /> instance that describes the return type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddGenericParameter(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a generic parameter type to the <paramref name="method" />.
            </summary>
      <param name="method">The target method.</param>
      <param name="parameterType">The parameter type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeReference" /> that represents the generic parameter type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal``1(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds a <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <typeparam name="T">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</typeparam>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal``1(Mono.Cecil.MethodDefinition,System.String)">
      <summary>
            Adds a named <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <typeparam name="T">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</typeparam>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <param name="variableName">The name of the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.ModuleDefinitionExtensions">
      <summary>
            A class that provides helper extension methods
            for the <see cref="T:Mono.Cecil.ModuleDefinition" /> class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.DefineClass(Mono.Cecil.ModuleDefinition,System.String,System.String,Mono.Cecil.TypeAttributes,Mono.Cecil.TypeReference)">
      <summary>
            Defines a new class and adds it to the <paramref name="mainModule" /> module.
            </summary>
      <param name="mainModule">The module which will hold the new created type.</param>
      <param name="typeName">The name of the class to create.</param>
      <param name="namespaceName">The namespace that will contain the new class.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.TypeAttributes" /> for the given type.</param>
      <param name="baseType">The base class of the new type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeDefinition" /> representing the new class being created.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportConstructor``1(Mono.Cecil.ModuleDefinition,System.Type[])">
      <summary>
            Imports a constructor with the given <paramref name="constructorParameters" />
            into the target <paramref name="module" />.
            </summary>
      <typeparam name="T">The type that holds the target constructor</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> that will import the target constructor.</param>
      <param name="constructorParameters">The list of <see cref="T:System.Type" /> objects that describe the signature of the constructor.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the constructor itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod(Mono.Cecil.ModuleDefinition,System.String,System.Type)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="declaringType">The <see cref="T:System.Type" /> instance that holds the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod(Mono.Cecil.ModuleDefinition,System.String,System.Type,System.Reflection.BindingFlags)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="declaringType">The <see cref="T:System.Type" /> instance that holds the target method.</param>
      <param name="flags">The <see cref="T:System.Reflection.BindingFlags" /> that describes the visibility and behavior of the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method.</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String,System.Type[])">
      <summary>
            Imports a method with a particular <paramref name="methodName" />, <paramref name="parameterTypes" />, and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method.</typeparam>
      <param name="parameterTypes">The list of <see cref="T:System.Type" /> objects that describe the method signature.</param>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String,System.Reflection.BindingFlags)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method itself.</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="flags">The <see cref="T:System.Reflection.BindingFlags" /> that describes the visibility and behavior of the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportType``1(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports a target of type <typeparamref name="T" /> into the
            <paramref name="module" /> instance.
            </summary>
      <typeparam name="T">The type that will be imported into the <see cref="T:Mono.Cecil.ModuleDefinition" /> instance itself.</typeparam>
      <param name="module">The module that will store the imported type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeReference" /> instance that represents the imported type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportType(Mono.Cecil.ModuleDefinition,System.Type)">
      <summary>
            Imports a <paramref name="targetType">target type</paramref> into the
            <paramref name="module" /> instance.
            </summary>
      <param name="targetType">The type that will be imported into the <see cref="T:Mono.Cecil.ModuleDefinition" /> instance itself.</param>
      <param name="module">The module that will store the imported type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeDefinition" /> instance that represents the imported type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.GetType(Mono.Cecil.ModuleDefinition,System.String)">
      <summary>
            Returns a <see cref="T:Mono.Cecil.TypeDefinition" /> that matches the given <paramref name="typeName" />.
            </summary>
      <param name="module">The target module to search.</param>
      <param name="typeName">The name of the target type.</param>
      <returns>A type that matches the given type name. If the type cannot be found, then this method will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.ParameterDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.ParameterDefinition" /> class
            to emulate features found in the System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.ParameterDefinitionExtensions.IsByRef(Mono.Cecil.ParameterDefinition)">
      <summary>
            Determines whether or not a parameter is passed by reference.
            </summary>
      <param name="parameter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.TypeDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.TypeDefinition" />
            class with features similar to the features in the
            System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.DefineMethod(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.MethodAttributes,Mono.Cecil.MethodCallingConvention,System.Type,System.Type[])">
      <summary>
            Adds a new method to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The type that will hold the newly-created method.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.MethodAttributes" /> parameter that describes the characteristics of the method.</param>
      <param name="methodName">The name to be given to the new method.</param>
      <param name="returnType">The method return type.</param>
      <param name="callingConvention">The calling convention of the method being created.</param>
      <param name="parameterTypes">The list of argument types that will be used to define the method signature.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> instance that represents the newly-created method.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.DefineMethod(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.MethodAttributes,System.Type,System.Type[],System.Type[])">
      <summary>
            Adds a new method to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The type that will hold the newly-created method.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.MethodAttributes" /> parameter that describes the characteristics of the method.</param>
      <param name="methodName">The name to be given to the new method.</param>
      <param name="returnType">The method return type.</param>
      <param name="parameterTypes">The list of argument types that will be used to define the method signature.</param>
      <param name="genericParameterTypes">The list of generic argument types that will be used to define the method signature.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> instance that represents the newly-created method.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddDefaultConstructor(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds a default constructor to the target type.
            </summary>
      <param name="targetType">The type that will contain the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddDefaultConstructor(Mono.Cecil.TypeDefinition,System.Type)">
      <summary>
            Adds a default constructor to the target type.
            </summary>
      <param name="parentType">The base class that contains the default constructor that will be used for constructor chaining..</param>
      <param name="targetType">The type that will contain the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,System.Type)">
      <summary>
            Adds a rewritable property to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:System.Type" /> instance that describes the property type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.TypeReference)">
      <summary>
            Adds a rewritable property to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> instance that describes the property type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.TypeReference,Mono.Cecil.MethodDefinition,Mono.Cecil.MethodDefinition)">
      <summary>
            Adds a rewriteable property to the <paramref name="typeDef">target type</paramref>
            using an existing <paramref name="getter" /> and <paramref name="setter" />.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> instance that describes the property type.</param>
      <param name="getter">The property getter method.</param>
      <param name="setter">The property setter method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)">
      <summary>
            Retrieves the method that matches the given <paramref name="methodName" />.
            </summary>
      <param name="typeDef">The target type to search.</param>
      <param name="methodName">The name of the target method.</param>
      <returns>A method that matches the given <paramref name="methodName" />. If the method is not found, then it will return a <c>null</c> value. </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.GetBackingField(System.String,Mono.Cecil.TypeDefinition,Mono.Cecil.TypeReference)">
      <summary>
            Resolves the backing field for a generic type declaration.
            </summary>
      <param name="fieldName">The name of the field to reference.</param>
      <param name="typeDef">The type that holds the actual field.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> that describes the property type being referenced.</param>
      <returns>A <see cref="T:Mono.Cecil.FieldReference" /> that points to the actual backing field.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddPropertyGetter(Mono.Cecil.TypeReference,System.String,Mono.Cecil.MethodAttributes,Mono.Cecil.FieldReference)">
      <summary>
            Creates a property getter method implementation with the
            <paramref name="propertyType" /> as the return type.
            </summary>
      <param name="propertyType">Represents the <see cref="T:Mono.Cecil.TypeReference">return type</see> for the getter method.</param>
      <param name="getterName">The getter method name.</param>
      <param name="attributes">The method attributes associated with the getter method.</param>
      <param name="backingField">The field that will store the instance that the getter method will retrieve.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> representing the getter method itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddPropertySetter(Mono.Cecil.TypeReference,Mono.Cecil.MethodAttributes,Mono.Cecil.FieldReference,System.String,Mono.Cecil.TypeReference)">
      <summary>
            Creates a property setter method implementation with the
            <paramref name="propertyType" /> as the setter parameter.
            </summary>
      <param name="propertyType">Represents the <see cref="T:Mono.Cecil.TypeReference">parameter type</see> for the setter method.</param>
      <param name="attributes">The method attributes associated with the setter method.</param>
      <param name="backingField">The field that will store the instance for the setter method.</param>
      <param name="setterName">The method name of the setter method.</param>
      <param name="voidType">The <see cref="T:Mono.Cecil.TypeReference" /> that represents <see cref="T:System.Void" />.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> that represents the setter method itself.</returns>
    </member>
  </members>
</doc>